<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Nginx | 织网]]></title>
  <link href="http://zheng-ji.github.com/blog/categories/nginx/atom.xml" rel="self"/>
  <link href="http://zheng-ji.github.com/"/>
  <updated>2015-03-10T00:23:04+08:00</updated>
  <id>http://zheng-ji.github.com/</id>
  <author>
    <name><![CDATA[zheng-ji]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[译]nginx pitfall]]></title>
    <link href="http://zheng-ji.github.com/blog/2014/05/13/nginx-pitfall/"/>
    <updated>2014-05-13T22:26:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2014/05/13/nginx-pitfall</id>
    <content type="html"><![CDATA[<p>今天看完<a href="http://wiki.nginx.org/Pitfalls">Nginx Pitfall</a>,热血用了一个下午翻译了的，以下是正文</p>

<h2 id="nginx-">Nginx 陷阱</h2>

<p>无论你是nginx的新用户还是老用户都会遇到nginx的一些陷阱，下面我们着重描述这些陷阱，以及如何避免犯错。这些问题多次出现在 #nginx channel on Freenode#上</p>

<h3 id="section">[是指南教我这么做的]</h3>

<p>不要轻易相信网上其他的配置指引，除非你知道这样做的真正意义，并且知道怎么清除它们。很多配置其实写的很糟糕，我们根据互联网上的错误配置收集到的陷阱，它们并非来自刻意搜索，而是来自网络上的疑惑问答，这些问题收到的共同回复是，他们因为看了一些错误配置指引所以不同意我们的方法。写此文的目的是为了阐述我们的观点，如果你也遇到如下问题，该文章正好为你准备。</p>

<h3 id="root-location">[Root 放置在Location块内]</h3>

<p>不好的配置</p>

<p><code>bash
server {
  server_name www.domain.com;
  location / {
    root /var/www/nginx-default/;
    [...]
  }
  location /foo {
    root /var/www/nginx-default/;
    [...]
  }
  location /bar {
    root /var/www/nginx-default/;
    [...]
  }
}
</code></p>

<p>该配置可以正常工作，把 root 放在 location块内可以完美的运行，但是当你开始添加location快，你就发现问题了。如果你给每个loaction 块添加 root，一旦有一个 location 块没有匹配到,那么他就失去了 root ,让我们来看看正确的配置</p>

<p><code>
server {
  server_name www.domain.com;
  root /var/www/nginx-default/;
  location / {
    [...]
  }
  location /foo {
    [...]
  }
  location /bar {
    [...]
  }
}
</code></p>

<h3 id="index-">[多条 index 指令]</h3>

<p>不好的配置</p>

<p><code>
http {
  index index.php index.htm index.html;
  server {
    server_name www.domain.com;
    location / {
      index index.php index.htm index.html;
      [...]
    }
  }
  server {
    server_name domain.com;
    location / {
      index index.php index.htm index.html;
      [...]
    }
    location /foo {
      index index.php;
      [...]
    }
  }
}
</code></p>

<p>为什么要重复多条不需要的 index 指令？事实上只需要用一次，它仅仅需要放置在 <code>http{}</code> 块内，后面的配置会继承它。</p>

<p>正确的配置</p>

<p><code>
http {
  index index.php index.htm index.html;
  server {
    server_name www.domain.com;
    location / {
      [...]
    }
  }
  server {
    server_name domain.com;
    location / {
      [...]
    }
    location /foo {
      [...]
    }
  }
</code></p>

<h3 id="if">[使用if]</h3>
<p>这里有小段篇幅是关于使用<code>if</code> 表达式，我们需要检查所谓的 “是否有害”，让我们看看那些错误的配置</p>

<p>不好的配置</p>

<p><code>
server {
  server_name domain.com *.domain.com;
  if ($host ~* ^www\.(.+)) {
    set $raw_domain $1;
    rewrite ^/(.*)$ $raw_domain/$1 permanent;
    [...]
  }
}
</code>
这里明显有问题，第一条 <code>if</code> 指令就引起我们的注意，为什么是不好的配置呢, 你是否阅读过 <a href="http://wiki.nginx.org/IfIsEvil">是否有害</a>。</p>

<p>使用if 指令，nginx 会强制检查所有到来的请求，检测每一条指令是否有危害，这是极度低效的。使用两个 server 配置可以避免上述问题。</p>

<p>正确的配置</p>

<p><code>
server {
  server_name www.domain.com;
  return 301 $scheme://domain.com$request_uri;
}
server {
  server_name domain.com;
  [...]
}
</code></p>

<p>这种方法不仅是配置易读，而且降低了 nginx 的处理负担。我们摆脱了<code>if</code>指令的陷阱，我们也使用了 <code>$scheme</code> 代替了 URI scheme 是 http 还是 https 的硬编码.</p>

<h3 id="section-1">[判断文件是否存在]</h3>

<p>使用 <code>if</code> 指令确保文件是否存在，是糟糕的实践，如果你有机会接触较新的 nginx 版本，查看下<code>try_files</code> 指令，该指令更适合做该事情。</p>

<p>不好的配置</p>

<p><code>
server {
  root /var/www/domain.com;
  location / {
    if (!-f $request_filename) {
      break;
    }
  }
}
</code></p>

<p>正确的配置</p>

<p><code>
server {
  root /var/www/domain.com;
  location / {
    try_files $uri $uri/ /index.html;
  }
}
</code></p>

<p>我们做的改变是，我们不使用<code>if</code>指令，而是使用 <code>try_files</code>,如果<code>$uri</code>不存在，尝试 <code>$uri/</code> 如果不存在，就使用默认的文件 <code>index.html</code></p>

<p>这个场景中，将会测试$uri是否存在，如果存在调用该服务，反之则会测试该目录是否存在，如果不存在就会调用 <code>index.html</code>，前提是<code>index.html</code>是存在的。这时候仅仅是简单的加载该页面。</p>

<h3 id="section-2">[包的前端控制器模式]</h3>

<p>“前端控制器模式”的设计很流行并广泛应用于 PHP 软件包，不乏很多比它更复杂的例子，使用 Drupal, Joomla 等，你只需要使用</p>

<p><code>
try_files $uri $uri/ /index.php?q=$uri&amp;$args;
</code></p>

<p>注意： - 参数名会依据你所使用的包不同而做相应的改变</p>

<ul>
  <li><code>q</code>用于Drupal, Joomla, WordPress</li>
  <li><code>page</code> 用于CMS Made Simple</li>
</ul>

<p>一些软件甚至不需要查询字符串，可以通过<code>REQUEST_URI</code>获取（比如WordPress就支持）</p>

<p><code>
try_files $uri $uri/ /index.php;
</code></p>

<p>当然，你的情况可能有所不一样，你可能需要更复杂的配置。对于简单的站点，该配置已经完美的支持，通常我们都是由浅入深地学习一样东西 。</p>

<p>如果你不关心目录是否存在，你可以决定跳过该目录检查,并且移 <code>$uri/</code></p>

<h3 id="php">[传递不受控制的请求给PHP]</h3>
<p>很多 PHP web 站点的 Nginx 配置要求，每一个URI需要附带<code>.php</code>给 PHP 解释器，注意到这里有一个关于PHP设置的严重安全隐患，因为它允许第三方执行任意代码。</p>

<p>比如</p>

<p><code>
location ~* \.php$ {
  fastcgi_pass backend;
  ...
}
</code></p>

<p>这里每一个关于.php的请求将会传给 <code>FastCGI</code> 后端，这是PHP默认配置，在不知道文件的具体路径下,试图通过该配置执行该文件。</p>

<p>举个例子，如果请求 <code>/forum/avatar/1232.jpg/file.php</code>不存在， PHP 解释器将会返回 <code>forum/avatar/1232.jpg</code>，如果该文件有内嵌php代码，就会相应地被执行了。</p>

<p>避免上述情况的配置选项是：</p>

<ul>
  <li>设置 php.ini 里的 <code>cgi.fix_pathinfo=0</code>，该配置使得 php 解释器仅仅执行具体制定的文件，停止执行不存在的文件。</li>
  <li>确保 nginx 指定具体的php可执行文件</li>
</ul>

<p><code>
location ~* (file_a|file_b|file_c)\.php$ {
  fastcgi_pass backend;
  ...
}
</code>
* 禁止执行用户上传目录中的php文件 </p>

<p><code>
location /uploaddir {
  location ~ \.php$ {return 403;}
  ...
}
</code></p>

<ul>
  <li>使用 <code>try_files</code>指令，过滤掉有问题的条件</li>
</ul>

<p><code>
location ~* \.php$ {
  try_files $uri =404;
  fastcgi_pass backend;
  ...
}
</code></p>

<ul>
  <li>使用嵌套块过滤有问题的条件</li>
</ul>

<p>```
location ~* .php$ {
  location ~ ..<em>/.</em>.php$ {return 404;}
  fastcgi_pass backend;
  …
}</p>

<p>```</p>

<h3 id="fastcgi-">[脚本文件名中的 FastCGI 路径]</h3>
<p>外界很多配置指引依靠绝对路径来获取你的信息，在PHP配置块内经常存在，当你从软件仓库中安装 nginx,他的配置文件中会有 “include fastcgi_params”,该文件在 nginx 文件夹 /etc/nginx 的目录下。</p>

<p>正确的配置</p>

<p><code>
fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;
</code></p>

<p>不好的配置</p>

<p><code>
fastcgi_param  SCRIPT_FILENAME    /var/www/yoursite.com/$fastcgi_script_name;
</code></p>

<p><code>$document_root</code> 在哪里呢？他在<code>server</code>块中<code>root</code>指令，如果你的<code>root</code> 指令配置不存在， 请回头看看 <code>第一个陷阱</code>。</p>

<h3 id="section-3">[麻烦的重写]</h3>
<p>不要感到沮丧，你很容易被正则表达式迷糊住。事实上，我们可以努力让配置干净简洁不添加毫不相干的东西。</p>

<p>不好的配置</p>

<p><code>
rewrite ^/(.*)$ http://domain.com/$1 permanent;
</code></p>

<p>不好的配置</p>

<p><code>
rewrite ^ http://domain.com$request_uri? permanent;
</code></p>

<p>正确的配置</p>

<p><code>
return 301 http://domain.com$request_uri;
</code></p>

<p>反复看这几个例子，OK，第一个重写捕获斜线前完整的URI。通过使用内置的变量 <code>$request_uri</code> 我们可以有效地避免做任何捕获或匹配,并通过返回指令,我们可以完全避免对正则表达式的使用。</p>

<h3 id="http">[重写时丢失<code>http://</code>]</h3>
<p>很简单，重写都是相互关联的，除非你特意设置nginx。重写规则挺简单的，仅仅添加一条规则。</p>

<p>不好的配置</p>

<p><code>
 rewrite ^/blog(/.*)$ blog.domain.com$1 permanent;
</code></p>

<p>正确的配置</p>

<p><code>
rewrite ^/blog(/.*)$ http://blog.domain.com$1 permanent;
</code></p>

<p>上述看到的例子，我们仅仅是给该条规则添加了<code>http://</code>，便实现了重写，很简单，也很实用。</p>

<h3 id="section-4">[代理一切]</h3>

<p>不好的配置</p>

<p>```
server {
    server_name example.org;
    root /var/www/site;</p>

<pre><code>location / {
    include fastcgi_params;
    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    fastcgi_pass unix:/tmp/phpcgi.socket;
} } ```
</code></pre>

<p>这个例子中，你转发请求给php,如果是 apache 服务器会这么干。但是 nginx 服务器不需要这样做，<code>try_files</code>指令会按顺序检测文件。这意味着nginx可以首先寻找需要测试的静态文件，如果找不到才返回用户指定的文件。通过这样的方式，php解释器不会执行任意php文件，除非你拥有该请求路径的php文件，而且能帮你节约资源，特别是当你直接通过php请求一个大小为1MB的图片1千次。</p>

<p>正确的配置</p>

<p>```
server {
    server_name example.org;
    root /var/www/site;</p>

<pre><code>location / {
    try_files $uri $uri/ @proxy;
}
 
location @proxy {
    include fastcgi.conf;
    fastcgi_pass unix:/tmp/php-fpm.sock;
} } ```
</code></pre>

<p>或者</p>

<p>```
server {
    server_name example.org;
    root /var/www/site;</p>

<pre><code>location / {
    try_files $uri $uri/ /index.php;
}
 
location ~ \.php$ {
    include fastcgi.conf;
    fastcgi_pass unix:/tmp/php-fpm.sock;
} } ```
</code></pre>

<p>如果被请求的 URI 存在就可以被 nginx 返回，如果不存在，那么是否存在一个具有index文件的目录里，同时，我们是否已经为该请求配置上了 index 指令。如果仍然不存在，重写规则将发送<code>index.php</code>到你的后端，只有当nginx前端不能处理你的请求，才会让后端服务参与进来。</p>

<p>想想有你的请求中有多少是静态资源，比如图片，css，javascript,我们可以通过上述方式的配置来节约这些资源。</p>

<h3 id="section-5">[配置改变，并没有生效]</h3>

<p>你的配置很完美，但是你依然捶胸顿足。问题出现在你的浏览器缓存上，当你加载一些东西，浏览器会保存下来，也会记住了它是如何请求服务的，如果你使用 <code>types{}</code>块，你会遇到如下问题。</p>

<p>修复</p>

<p>[选项1] 在火狐中按下 <code>Ctrl+Shift+Delet</code> ,检测缓存，并且清空。其他的浏览器自行搜索清空缓存的方法，每一次修改配置，记得清空缓存，除非你确认不需要这么做，这一步骤会帮你避免很多头痛。</p>

<p>在火狐中，你也可以选择一个更长久的解决方法，在URI搜索条内，输入<code>about:config</code>,然后搜索 <code>browser.cache.check_doc_frequency</code> ，设置其值为1，这样没加载一次包就会检测。</p>

<p>[选项2] 使用 <code>curl</code>
如果还行不通，而且你是在<code>vritualbox</code> 虚拟机里面运行 nginx,那么，可能是 <code>sendfile()</code> 惹得祸，你只需要注释掉 sendfile 指令，或者将其设置为 <code>off</code>,这个指令在<code>nginx.conf</code>里。</p>

<p><code>
sendfile off
</code></p>

<h3 id="http-1">[HTTP头部丢失]</h3>

<p>如果你没有显性设置 </p>

<p><code>
 underscores_in_headers on
</code></p>

<p>nginx 将会默认用下划线去掉http头部（这符合http标准），这么做是为了防止在映射CGI头信息时候有歧义。这个过程中破折号和下划线都被映射成了下划线。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nginx+lua应对在线状态服务]]></title>
    <link href="http://zheng-ji.github.com/blog/2013/09/12/nginx-plus-luaying-dui-zai-xian-zhuang-tai-fu-wu/"/>
    <updated>2013-09-12T23:12:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2013/09/12/nginx-plus-luaying-dui-zai-xian-zhuang-tai-fu-wu</id>
    <content type="html"><![CDATA[<p>几天前在@ideawu的博客上看到了其一篇文章中讲到的技术题.
<a href="http://www.ideawu.net/blog/archives/732.html">《在线状态服务在网站系统中的应用》</a> 。于是内心折腾的火焰便熊熊燃烧起来，连续几天晚上折腾到凌晨1点。感谢@agentzh 春哥与阿里巴巴的技术贡献,让我可以安心睡觉 :) </p>

<p>在线状态服务这样的场景在互联网应用上比比皆是</p>

<ul>
  <li>聊天系统中同时在线的人数</li>
  <li>游戏中同时在线玩家等</li>
</ul>

<p>文中所言,现实的在线状态应用场景是:
网页中用JavaScript启动一个定时器, 定期报告在线状态, 也就是向在线状态服务器发送心跳包.对某个同时在线100万人, 每天1亿PV的网站来说, 在线状态服务器一天接收到的心跳包大概是10亿个, 也即每秒10000个请求(10000qps).要实现这样的在线状态服务器, 也是一个挑战.</p>

<p>好了，我当时真的很兴奋，感觉自己像接到了任务，立马打起了鸡血研究. 脑海中涌现出来的直觉是，使用tornado + Redis，这样的高并发组合应对这样的场景应该是无压力的，但是因为这样的事情我做过，想挑战自己非舒适的区域，挖掘新的知识大陆。
我们一直都说，没有经过打磨的想法一般都是廉价的。后来我想到的是Ngnix这样的服务器来抗如此高的请求，那么我们就自己写个拓展，查询内存数据库，这里我选择用redis来做kv内存数据库，</p>

<p>文中谈到的自己设计精巧的kv数据库，甚至用C++写针对性的http服务，来提升通用服务器的性能。曾经写过一个KV数据库，其性能真的是渣渣。<a href="https://github.com/zheng-ji/KvDb">源码链接</a>。欢迎吐槽.
一直以来听闻春哥的nginx lua模块拓展，可以为nginx定制业务。想想以前用c语言实现，简直就是痛苦,这一次可以使用lua，甚为欢悦，没有什么比探索新东西带来的乐趣更令人振奋了</p>

<p>首先要有lua的运行环境。他是一种胶水粘合剂 ：） 还必须安装<strong>luajit</strong></p>

<p><code>
#设置环境变量，后续安装需要
shell&gt; export LUAJIT_LIB=/usr/local/lib
shell&gt; export LUAJIT_INC=/usr/local/include/luajit-&lt;VERSION&gt;
</code></p>

<h4 id="nginx-">需要安装的nginx 插件</h4>

<p><code>
ngx_devel_kit https://github.com/simpl/ngx_devel_kit
set-misc-nginx-module https://github.com/agentzh/set-misc-nginx-module
memc-nginx-module https://github.com/agentzh/memc-nginx-module 
lua-nginx-module https://github.com/chaoslawful/lua-nginx-module
</code></p>

<h4 id="nginx">下载之后，安装nginx插件</h4>

<p><code>
./configure --prefix=/path/to/nginx_src --add-module=/path/to/ngx_devel_kit --add-module=set-misc-nginx-module \
--add-module=/path/to/lua-nginx-module -add-module=ngx_devel_kit 
make 
make install
</code></p>

<p>nginx.conf 文件                 </p>

<p>```
location /echo {<br />
    default_type ‘text/plain’;<br />
    echo ‘hello echo’;<br />
}  </p>

<p>location /lua {<br />
    default_type ‘text/plain’;<br />
    content_by_lua ‘ngx.say(“hello, lua”)’;<br />
}<br />
```</p>

<p>也许你会遇到一些麻烦,执行如下命令</p>

<p><code>
shell&gt; echo "/usr/local/lib" &gt; /etc/ld.so.conf.d/usr_local_lib.conf
shell&gt; ldconfig
</code></p>

<p>重启服务器之后，应该就可以看到hello,lua :) (到这里仅仅是开始，折腾了有点久)</p>

<h3 id="ideawu-">好了，来完成ideawu的作业 ：）</h3>

<blockquote>
  <p>在线状态服务, 是这样的一个服务, 它维护了网站当前的在线用户列表, 接受其它模块的查询. 是实现统计网站同时在线人数, 维护在线用户列表等功能的基础服务. 在Facebook的聊天系统中, 在线状态是为聊天系统服务的, 所以在线状态是一种”强”在线, 也即用户保持着和Comet服务器的连接, 可随时接受服务器推送(push)的消息.在高并发请求的情况下如何完成该需求呢</p>
</blockquote>

<p>使用 Lua 脚本语言操作 Redis。这里使用 content_by_lua_file （nginx_lua_module 模块具有）来引入 Lua 脚本文件。
agentzh 提供了一个很方便的开发包，如下：<a href="https://github.com/agentzh/lua-resty-redis.git">lua-resty-redis</a></p>

<p>该包中，有一个 lib 目录，将 lib 目录下的文件和子目录拷贝至目录 /home/zj/soft/data/www/lua/
在 Nginx 配置文件中，需要加一行代码，以便引入 redis.lua。
注：加在 http 段里。</p>

<p><code>
lua_package_path "/home/zj/soft/data/www/lua//?.lua;;";  
</code></p>

<p>为了使得 lua 脚本的修改能及时生效，需要加入一行代码，如下：注：在 server 段里，加入代码，如果不加此代码或者设置为 on 时，则需要重启 Nginx。 不过nginx 会报警</p>

<p><code>
lua_code_cache off;  
</code></p>

<p>nginx.conf 里</p>

<p><code>
location /getolNum {
    content_by_lua_file /conf/online.lua;  
} 
</code></p>

<h5 id="onlinelua-">online.lua 源码</h5>

<p>```lua
local redis = require “redis”
local cache = redis.new()</p>

<p>local ok, err = cache.connect(cache, ‘127.0.0.1’, ‘6379’)
if not ok then
    ngx.say(“failed to connect:”, err)
    return
end</p>

<p>cache:set_timeout(30000)
args = ngx.req.get_uri_args()
user = args[“user”]
–设置用户 3 min 过期
cache:setex(user,180,23)</p>

<p>local res,err = cache:keys(‘*’)</p>

<p>–count res num
count = 0
for _ in pairs(res) do
    count = count + 1
end
ngx.say(count)
local ok, err = cache:close()
```</p>

<p>结果</p>

<p><code>
curl localhost/getOlnum?user=zj
返回：1
curl localhost/getOlnum?user=zhengji
返回：2
</code></p>

<p>Happy Hacking :)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nginx模块开发]]></title>
    <link href="http://zheng-ji.github.com/blog/2013/02/17/nginxmo-kuai-kai-fa/"/>
    <updated>2013-02-17T14:04:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2013/02/17/nginxmo-kuai-kai-fa</id>
    <content type="html"><![CDATA[<p>写这篇文章的时候，参考<a href="http://blog.codinglabs.org/articles/intro-of-nginx-module-development.html">链接</a>，特此鸣谢</p>

<h4 id="whyngnix-">Why要开发Ngnix 模块：</h4>

<blockquote>
  <p>对于一些访问量特别大，业务逻辑也相对简单的Web调用来说，通过一个nginx module来实现是一种比较好的优化方法。实现一个nginx module实际上比较简单。（@TimYang）</p>
</blockquote>

<h4 id="nginx-">Nginx 配置结构了解</h4>
<p>Nginx的配置文件是以block的形式组织的，一个block通常使用大括号“{}”表示。block分为几个层级，整个配置文件为main层级，这 是最大的层级；在main层级下可以有event、http等层级，而http中又会有server block，server block中可以包含location block</p>

<h4 id="nginx">Nginx模块工作原理概述</h4>
<p>Nginx本身做的工作实际很少，当它接到一个HTTP请求时，它仅仅是通过查找配置文件将此次请求映射到一个location block，而此location中所配置的各个指令则会启动不同的模块去完成工作，因此模块可以看做Nginx真正的劳动工作者。通常一个 location中的指令会涉及一个handler模块和多个filter模块（当然，多个location可以复用同一个模块）。handler模块负 责处理请求，完成响应内容的生成，而filter模块对响应内容进行处理。因此Nginx模块开发分为handler开发和filter开发</p>

<h4 id="nginx-1">展示一个简单的Nginx模块开发全过程</h4>
<p>我们开发一个叫echo的handler模块，这个模块功能非常简单，它接收“echo”指令，指令可指定一个字符串参数，模块会输出这个字符串作为HTTP响应。例如，做如下配置：</p>

<p><code>
location /echo {
    echo "hello nginx";
}
</code></p>

<table>
  <tbody>
    <tr>
      <td>首先我们需要一个结构用于存储从配置文件中读进来的相关指令参数，即模块配置信息结构。根据Nginx模块开发规则这个结构的命名规则为ngx_http<em>[module-name]</em>[main</td>
      <td>srv</td>
      <td>loc]_conf_t</td>
    </tr>
  </tbody>
</table>

<p>实现这个功能需要三步：
+ 读入配置文件中echo指令及其参数；
+ 进行HTTP包装（添加HTTP头等工作）；
+ 将结果返回给客户端。</p>

<h4 id="nginx-2">Nginx模块的安装</h4>
<p>Nginx不支持动态链接模块，所以安装模块需要将模块代码与Nginx源代码进行重新编译。安装模块的步骤如下：</p>

<ul>
  <li>编写模块config文件，这个文件需要放在和模块源代码文件放在同一目录下。文件内容如下：</li>
</ul>

<p><code>
ngx_addon_name=模块完整名称
HTTP_MODULES=”$HTTP_MODULES 模块完整名称”
NGX_ADDON_SRCS=”$NGX_ADDON_SRCS $ngx_addon_dir/源代码文件名”
</code></p>

<ul>
  <li>进入Nginx源代码，使用下面命令编译安装</li>
</ul>

<p><code>
./configure --prefix=安装目录 --add-module=模块源代码文件目录
make
make install
</code></p>

<p>这样就完成安装了，例如，我的源代码文件放在/home/zj/tmp/ngx/ngx_http_echo下，我的config文件为：</p>

<p><code>
ngx_addon_name=ngx_http_echo_module
HTTP_MODULES="$HTTP_MODULES ngx_http_echo_module"
NGX_ADDON_SRCS="$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_echo_module.c"
</code></p>

<h4 id="section">编译安装命令为：</h4>

<p><code>
./configure --prefix=/usr/local/nginx --add-module=/home/zj/tmp/ngx/ngx_http_echo
make
sudo make install
</code></p>

<p>这样echo模块就被安装在我的Nginx上了，下面测试一下，修改配置文件，增加以下一项配置：</p>

<p><code>
location /echo {
    echo "This is my first nginx module!!!";
}
</code></p>

<p>然后用curl测试一下：</p>

<p><code>
curl -i http://localhost/echo
</code></p>
]]></content>
  </entry>
  
</feed>
