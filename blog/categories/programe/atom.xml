<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programe | 织网]]></title>
  <link href="http://zheng-ji.github.com/blog/categories/programe/atom.xml" rel="self"/>
  <link href="http://zheng-ji.github.com/"/>
  <updated>2016-09-25T23:41:33+08:00</updated>
  <id>http://zheng-ji.github.com/</id>
  <author>
    <name><![CDATA[zheng-ji]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CuckooFilter，BloomFilter的优化]]></title>
    <link href="http://zheng-ji.github.com/blog/2016/08/01/cuckoofilter/"/>
    <updated>2016-08-01T19:48:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2016/08/01/cuckoofilter</id>
    <content type="html"><![CDATA[<p>面对海量数据，我们需要一个索引数据结构，用来帮助查询，快速判断数据记录是否存在，这类数据结构叫过滤器，常用的选择是 <code>Bloom Filter</code>. 而 <code>Cuckoo Filter</code> 是它的优化变种。借此也用 Golang 实践了这个<a href="https://github.com/zheng-ji/goCuckoo">算法</a>。</p>

<p><img src="https://cloud.githubusercontent.com/assets/1414745/17084380/8c3a4896-51ee-11e6-869e-b087226cc5ce.jpg" alt="goCuckoo" /></p>

<p><code>Bloom Filter</code> 的位图模式有两个问题：</p>

<ul>
  <li>误报，它能判断元素一定不存在，但只能判断可能存在，因为存在其它元素被映射到部分相同位上，导致该位置1，那么一个不存在的元素可能会被误报成存在；</li>
  <li>漏报，如果删除了某个元素，导致该映射位被置0，那么本来存在的元素会被漏报成不存在。 </li>
</ul>

<p><code>Cuckoo Filter</code>，可以确保该元素存在的必然性，又可以在不违背此前提下删除任意元素，仅仅比 <code>Bloom Filter</code> 牺牲了微量空间效率。 它的的数据模型: </p>

<ul>
  <li>每个元素对应两个哈希算法，在哈希碰撞时会启用备用哈希算法。</li>
  <li>每一个桶是有4路的，每个槽对应一个指纹。</li>
</ul>

<p><img src="https://cloud.githubusercontent.com/assets/1414745/17103421/c97635e0-52b0-11e6-83ac-1b1fdbb5d31c.png" alt="model" /></p>

<h2 id="feature">Feature</h2>

<ul>
  <li>支持删除操作</li>
  <li>支持快速查找，支持 O(1) 查找速度</li>
  <li>高效的空间利用，四路槽的表，可以有95% 的空间利用率</li>
  <li>可替代布隆过滤器</li>
</ul>

<h2 id="installation">Installation</h2>

<p><code>
go get github.com/zheng-ji/goCuckoo
</code></p>

<h2 id="example">Example</h2>

<p>```go
import (
	“fmt”
	“github.com/zheng-ji/goCuckoo”
)</p>

<p>func main() {
    // speicify capacity 
	filter := cuckoo.NewCuckooFilter(10000)</p>

<pre><code>filter.Insert([]byte("zheng-ji"))
filter.Insert([]byte("stupid"))
filter.Insert([]byte("coder"))

if filter.Find([]byte("stupid")) {
	fmt.Println("exist")
} else {
	fmt.Println("Not exist")
}

filter.Del([]byte("stupid"))
filter.Println(filter.Size()) } ```
</code></pre>

<h2 id="section">参考</h2>

<ul>
  <li><a href="http://www.cs.cmu.edu/~binfan/papers/conext14_cuckoofilter.pdf">CMU Paper</a></li>
  <li><a href="http://www.cs.cmu.edu/~binfan/papers/conext14_cuckoofilter.pptx">CMU PPT</a></li>
  <li><a href="http://coolshell.cn/articles/17225.html">CoolShell Article</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Celery的Crontab实践]]></title>
    <link href="http://zheng-ji.github.com/blog/2016/07/23/celeryde-crontabshi-jian/"/>
    <updated>2016-07-23T20:19:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2016/07/23/celeryde-crontabshi-jian</id>
    <content type="html"><![CDATA[<p>有时候我们需要处理耗时的操作，同时又要保持较快的响应速度，就需要借助异步队列的帮助。Celery 作为异步队列服务，想必是很多人和我一样的选择。用法在官方文档也详细介绍，不再赘述。</p>

<p>这次想记录的是用 Celery 来实现定时任务。这里也有一点点坑。</p>

<p>以下是 <code>main.py</code> 的内容</p>

<p>```py
from celery import Celery
from lib import distribute
from celery.schedules import crontab</p>

<p>app = distribute.app
app.conf.update(
    CELERYBEAT_SCHEDULE = {
        ‘every-minute’: {
            ‘task’: ‘test_cron’,
            ‘schedule’: crontab(minute=”*”),
            ‘args’: (16, 13),
        }
    },
    CELERY_INCLUDE=(“apps.tasks”,)
)
if <strong>name</strong> == ‘<strong>main</strong>’:
    app.start()
```</p>

<p>实际工作单元,我放在 apps 目录下的 <code>tasks.py</code> 文件中</p>

<p><code>py
from lib.distribute import app
@app.task(name="test_cron")
def mul(x, y):
    return x * y
</code></p>

<p>上述是一个简单的 Crontab 应用，它仅需要以下命令就能执行,
其中  <code>--beat</code> 表示 crontab 的应用</p>

<p><code>
python main.py worker --beat -l info
</code></p>

<p>起初我想把异步队列和定时任务放在一起,就加上了一句 CELERY_QUEUES 的配置</p>

<p><code>py
app.conf.update(
    // 添加的部分
    CELERY_QUEUES=(
        Queue(
          'test', Exchange('test_exchange'),
           routing_key='test_queue'
        ),
    ),
    CELERYBEAT_SCHEDULE = {
        'every-minute': {
            'task': 'test_cron',
            'schedule': crontab(minute="*"),
            'args': (16, 13),
        }
    },
    CELERY_INCLUDE=("apps.tasks",)
)
</code></p>

<p>同样用上述命令开启worker，发现这个时候 Crontab 不能工作了，后来看到官方的文档：</p>

<blockquote>
  <p>celery beat and celery worker as separate services instead. </p>
</blockquote>

<p>也就是说 Celery 的 Beat 需要和其他异步worker 分开，单独执行。</p>

<p>相关代码<a href="https://github.com/zheng-ji/ToyCollection/tree/master/celery_proj">链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记录使用 Flask 的点滴]]></title>
    <link href="http://zheng-ji.github.com/blog/2015/10/06/ji-lu-shi-yong-flaskde-dian-di/"/>
    <updated>2015-10-06T13:21:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2015/10/06/ji-lu-shi-yong-flaskde-dian-di</id>
    <content type="html"><![CDATA[<p>喜欢 Flask 经典的 RestFul 设计风格，以及它与 Gevent 的优雅结合，可以帮助我们轻松构建异步非阻塞应用，烂笔头记下一些较好的实践。</p>

<ul>
  <li><a href="#第一节">消息反馈</a></li>
  <li><a href="#第二节">Flask 上下文</a></li>
  <li><a href="#第三节">注册 JinJia 模板过滤器</a></li>
  <li><a href="#第四节">itsdangerous 生成过期时间 Json 签名</a></li>
  <li><a href="#第五节">一种较好的项目组织方式</a></li>
  <li><a href="#第六节">BluePrint 的好</a></li>
  <li><a href="#第七节">Json 返回</a></li>
  <li><a href="#第八节">自定义出错页面</a></li>
  <li><a href="#第九节">WTF 跨站脚本防御</a></li>
</ul>

<h3 id="第一节">消息反馈</h3>

<p>Flask 提供了一个非常简单的方法来使用闪现系统向用户反馈信息。
闪现系统使得在一个请求结束的时候记录一个信息，然后在且仅仅在下一个请求中访问这个数据。这通常配合一个布局模板实现</p>

<p><a href="http://docs.jinkan.org/docs/flask/patterns/flashing.html">文档链接</a></p>

<p>```
# 视图函数需要调用
flash(‘your response message for user’)</p>

<h1 id="section">前端页面调用</h1>
<p>for message in get_flashed_messages()
就可以输出反馈信息
```</p>

<h3 id="第二节">Flask 上下文</h3>

<p>有两种上下文：程序上下文，请求上下文</p>

<ul>
  <li>current_app： 程序级别上下文，当前激活程序的实例。</li>
  <li>g: 请求级别的上下文</li>
  <li>request: 是请求级别的上下文，封装了客户端发出的 Http 请求中的内容</li>
  <li>session: 用户会话，用于存储请求之间需要记住的键值对</li>
</ul>

<h3 id="第三节">注册 JinJia 模板过滤</h3>

<p>```
def reverse_filter(s):
    return s[::-1]</p>

<p>app.jinja_env.filters[‘reverse’] = reverse_filter
```</p>

<h3 id="第四节">itsdangerous 生成过期时间 Json 签名</h3>

<p>```
serialaizer = Serializer(SECRET_KEY, expires_in=EXPIRES)
info = {‘id’:’xxx’}
session = serialaizer.dumps(info)</p>

<h1 id="session-">判断 session 时间</h1>
<p>info = None
try:
    info = serialaizer.loads(session)
except Exception:
    return jsonify(ERR_SESS_TIMEOUT)
```</p>

<p>用途：生成一个有时间限制的签名，用于API 访问的验证码，如果过期，提醒用户重新登录</p>

<h3 id="第五节">一种较好的项目组织方式</h3>

<p><code>
▾ app/
    ▾ controlers/
        ▾ admin/                    #管理后台的蓝图控制器
            ▾ forms/                #表单限制文件
                __init__.py　　　　　
                xx.py　　　         # blueprint 文件
            __init__.py
            administrator.py
        ▾ api/                      # API 控制器
            __init__.py
        ▾ site/                     # 站点控制器
            __init__.py             # blueprint 文件
            xx.py
        __init__.py
        error.py
    ▸ models/         # SQLAlchemy 的各类模型
    ▸ static/         # 需要的静态资源，css, js, imgs
    ▾ templates/　　　# 前端页面，跟 controller 分类一一对应
        ▸ admin/
        ▸ error/
        ▸ site/
    ▸ utilities/　　　　#  功能函数
      __init__.py       #　初始化app需要的各种插件，比如 redis, db, 注册蓝图
run.py                  #　相当于 main 函数,创建 app, 执行app.run() 函数
settings.py             #　配置文件
</code></p>

<h3 id="第六节">BluePrint 的好 </h3>

<p>每个 Blueprint 就像独立的 Application, 可以管理自己的模板, 路由, 反向路由url_for, 甚至是静态文件，最后统一挂载到 Application 下。从头到尾都是 RestFul。</p>

<p>在创建 app (app/<strong>init</strong>.py) 的时候调用如下:</p>

<p><code>
from app.controllers.site.console import console 
app.register_blueprint(console, url_prefix='/console')
</code></p>

<p>视图文件 (app/controllers/site/console.py):</p>

<p><code>
console = BLueprint('console', __name__)
</code></p>

<h3 id="第七节">Json 返回</h3>

<p><code>
from flask import jsonify
return jsonify({'code': 0})
</code></p>

<h3 id="第八节">自定义出错页面</h3>

<p>```
@app.errorhandler(404)
def not_found(error):
    return render_template(‘404.html’), 404</p>

<p>@app.errorhandler(500)
def crash(error):
    return render_template(‘5xx.html’), 500
```</p>

<h3 id="第九节">WTF 跨站脚本防御</h3>

<p>Flask-WTF 能保护表单免受跨站请求伪造的攻击,恶意网站把请求发送到被攻击者已经登录的其他玩战会引发 CSRF 攻击</p>

<ul>
  <li>app config 文件中，开启 CSRF 开关并配置密钥</li>
</ul>

<p><code>
CSRF_ENABLED = True
SECRET_KEY = 'you-will-never-guess'
</code></p>

<ul>
  <li>表单的定义</li>
</ul>

<p><code>
from flask.ext.wtf import Form, TextField, BooleanField
from flask.ext.wtf import Required
class LoginForm(Form):
    openid = TextField('openid', validators = [Required()])
    remember_me = BooleanField('remember_me', default = False)
</code></p>

<ul>
  <li>页面渲染</li>
</ul>

<p><code>
&lt;form action="" method="post" name="login"&gt;
    form.hidden_tag()
    &lt;p&gt; Please enter your OpenID:form.openid(size=80)&lt;br&gt;&lt;/p&gt;
    &lt;p&gt;form.remember_me &lt;/p&gt;
    &lt;p&gt;&lt;input type="submit" value="Sign In"&gt;&lt;/p&gt;
&lt;/form&gt;
</code></p>

<ul>
  <li>控制器函数</li>
</ul>

<p><code>
@app.route('/login', methods = ['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        flash('Login requested for OpenID="' + form.openid.data))
        return redirect('/index')
    return render_template('login.html', title = 'Sign In',form = form)
</code></p>

<p>我们在配置中开启了CSRF(跨站伪造请求)功能，模板参数 form.hidden_tag() 会被替换成一个具有防止CSRF功能的隐藏表单字段。 在开启了CSRF功能后，所有模板的表单中都需要添加这个模板参数</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 使用 LDAP]]></title>
    <link href="http://zheng-ji.github.com/blog/2015/10/01/python-shi-yong-ldap/"/>
    <updated>2015-10-01T09:49:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2015/10/01/python-shi-yong-ldap</id>
    <content type="html"><![CDATA[<h2 id="section">写在开头</h2>

<p>过去的两个多星期，几位小伙伴同心协力完成一个自研的，类似<a href="http://pushover.net">pushover</a>的产品。感谢 Leader 的信任，让我在负责开发的同时也兼顾了一把项目经理。谢谢 IOS, Android 客户端的兄弟，设计师的支持，还有一位实习生，开心看到他的点滴成长。</p>

<p>提下背景，我们之前使用 <code>pushover</code> 来做报警推送，但是它对天朝用户不友好，Android 用户需要翻墙才能使用，有时候不稳定，体现为会收不到信息。pushove 需要付费。我们的受众不仅有程序汪，还有运营产品汪，他们需要一款更容易上手的推送软件，至少不需要番羽墙。于是自己开发一个很有必要。</p>

<p>为最大程度降低用户使用门槛，同时保证用户信息的安全，我们用了 LDAP 账户登陆，严格控制权限，以及 HTTPS 协议开发。下面提一提 LDAP 这个东西。</p>

<h2 id="ldap-">LDAP 是什么</h2>

<p><a href="https://zh.wikipedia.org/wiki/%E8%BD%BB%E5%9E%8B%E7%9B%AE%E5%BD%95%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE">LDAP维基百科</a></p>

<p>简单地讲，它是以目录树的方式存放账户信息。</p>

<p>这次项目中，我们不希望用户重新注册账户，而是采用原有的用户体系，这样对单点登录以及权限控制的好处不严而喻, LDAP 协议呼之欲出。</p>

<h2 id="virtualenv--python-ldap">virtualenv 下安装 python-ldap</h2>

<p>我们采用 Python 开发，这就需要 python-ldap 的帮助了, 记下安装笔记的好处是下次不用在此纠结太长时间。</p>

<p><code>
apt-get install libsasl2-dev python-dev libldap2-dev libssl-dev
pip install python-ldap
</code></p>

<h2 id="section-1">身份验证</h2>

<p><code>
# LDAP 服务的域名和端口
SERVER_NAME = 'xxxx'
SERVER_PORT = xxx
try:
    conn = ldap.open(SERVER_NAME, SERVER_PORT)  
    conn.protocol_version = ldap.VERSION3 #设置ldap协议版本 
    username = "user=xxx,dc=company,dc=com" #身份信息
    password = "xxx" #访问密码
    conn.simple_bind_s(username,password) # 开始绑定，验证成功的话不会抛出异常
except ldap.LDAPError, e: #捕获出错信息
    print e
</code></p>

<h2 id="section-2">一点感悟</h2>

<p>鄙人觉得，技术领导要带领项目成长, 除了有责任把控项目风险，推进项目进度。
还必须要花很多的心血在驾驭技术上,  身先士卒去调研可行性, 以及做技术攻关，
而非命令式地分配任务，让同事干活, 只问责结果。
否则很容易导致凝聚力不足,团队技术氛围不足，这样的团队易消极，也易滋生失败的项目。
然而在天朝, 很多人存在一个潜意识:写好代码是为了以后不写代码，这种阶级思想让我反感。</p>

<p>以前看过一个新闻, 硅谷在面试技术 VP ，仍然要求其在各位工程师面前手写代码，以此作为面试的重要环节, 不得不点赞。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[轻巧实时统计用户数]]></title>
    <link href="http://zheng-ji.github.com/blog/2015/06/11/qing-qiao-shi-shi-tong-ji-yong-hu-shu/"/>
    <updated>2015-06-11T23:14:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2015/06/11/qing-qiao-shi-shi-tong-ji-yong-hu-shu</id>
    <content type="html"><![CDATA[<h2 id="section">背景</h2>

<p>最近在优化一个短地址的统计服务，之前是使用 Cookie 来做统计每天的UV，而且这个需求是近乎实时的，
业务方需要每5分钟就能看到最新统计结果。但有些情况我们是取不到Cookie的，比如服务器对服务器的狂刷访问，那么UV就计算不准确，
是时候要改造方案了。</p>

<p>后来我用 IP+UserAgent 来识别用户，从而统计 UV。好了，接下来你会怎么做这个实时统计呢？</p>

<h2 id="section-1">两个方案的选择</h2>

<ul>
  <li>Plan A：</li>
</ul>

<p>将每天的 <code>IP+UA</code> 存进 Redis 的 Set 集合里，它会自动去重，然后计算该集合里元素的个数得到结果，此方案似乎不错，
但真的好吗？假如每天大概有200W个UV，1个用户标识<code>IP+UA</code>需要大概150个字节，那么大约要耗费300MB的内存。</p>

<p>觉得内存太宝贵，应该有更好的方法，想起了位运算， 于是就有了</p>

<ul>
  <li>Plan B:</li>
</ul>

<p>将 <code>IP+UA</code> 组合成的字符串哈希成一个数值，然后借助 Redis 的 BitSet 数据结构求出<code>UV</code>。以下是伪代码</p>

<p>```
conn = redis()
index = hash(UA+IP)
key = “xxx_2015-05-10”
conn.do(‘SETBIT’, key, index, 1) # 将该hash值对应的位赋值为1</p>

<p>realtime_uv = conn.do(‘BITCOUNT’, key) # 得到实时的uv
```</p>

<p>根据业务的情况，我的hash桶开了200W个位，大概需要消耗2M的内存，的确节约不少空间，位运算的效率也很快。
于是欣然选择 Plan B</p>

<h2 id="section-2">一些链接</h2>

<ul>
  <li><a href="https://redis.readthedocs.org/en/2.4/set.html">Redis Set</a></li>
  <li><a href="http://redis.io/commands/SETBIT">Redis BitSet</a></li>
  <li><a href="http://blog.nosqlfan.com/html/3501.html">NoSQLFan 一个文章</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
