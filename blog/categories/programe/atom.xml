<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programe | 织网]]></title>
  <link href="http://zheng-ji.github.com/blog/categories/programe/atom.xml" rel="self"/>
  <link href="http://zheng-ji.github.com/"/>
  <updated>2016-06-03T23:49:00+08:00</updated>
  <id>http://zheng-ji.github.com/</id>
  <author>
    <name><![CDATA[zheng-ji]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[记录使用 Flask 的点滴]]></title>
    <link href="http://zheng-ji.github.com/blog/2015/10/06/ji-lu-shi-yong-flaskde-dian-di/"/>
    <updated>2015-10-06T13:21:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2015/10/06/ji-lu-shi-yong-flaskde-dian-di</id>
    <content type="html"><![CDATA[<p>喜欢 Flask 经典的 RestFul 设计风格，以及它与 Gevent 的优雅结合，可以帮助我们轻松构建异步非阻塞应用，烂笔头记下一些较好的实践。</p>

<ul>
  <li><a href="#第一节">消息反馈</a></li>
  <li><a href="#第二节">Flask 上下文</a></li>
  <li><a href="#第三节">注册 JinJia 模板过滤器</a></li>
  <li><a href="#第四节">itsdangerous 生成过期时间 Json 签名</a></li>
  <li><a href="#第五节">一种较好的项目组织方式</a></li>
  <li><a href="#第六节">BluePrint 的好</a></li>
  <li><a href="#第七节">Json 返回</a></li>
  <li><a href="#第八节">自定义出错页面</a></li>
  <li><a href="#第九节">WTF 跨站脚本防御</a></li>
</ul>

<h3 id="第一节">消息反馈</h3>

<p>Flask 提供了一个非常简单的方法来使用闪现系统向用户反馈信息。
闪现系统使得在一个请求结束的时候记录一个信息，然后在且仅仅在下一个请求中访问这个数据。这通常配合一个布局模板实现</p>

<p><a href="http://docs.jinkan.org/docs/flask/patterns/flashing.html">文档链接</a></p>

<p>```
# 视图函数需要调用
flash(‘your response message for user’)</p>

<h1 id="section">前端页面调用</h1>
<p>for message in get_flashed_messages()
就可以输出反馈信息
```</p>

<h3 id="第二节">Flask 上下文</h3>

<p>有两种上下文：程序上下文，请求上下文</p>

<ul>
  <li>current_app： 程序级别上下文，当前激活程序的实例。</li>
  <li>g: 请求级别的上下文</li>
  <li>request: 是请求级别的上下文，封装了客户端发出的 Http 请求中的内容</li>
  <li>session: 用户会话，用于存储请求之间需要记住的键值对</li>
</ul>

<h3 id="第三节">注册 JinJia 模板过滤</h3>

<p>```
def reverse_filter(s):
    return s[::-1]</p>

<p>app.jinja_env.filters[‘reverse’] = reverse_filter
```</p>

<h3 id="第四节">itsdangerous 生成过期时间 Json 签名</h3>

<p>```
serialaizer = Serializer(SECRET_KEY, expires_in=EXPIRES)
info = {‘id’:’xxx’}
session = serialaizer.dumps(info)</p>

<h1 id="session-">判断 session 时间</h1>
<p>info = None
try:
    info = serialaizer.loads(session)
except Exception:
    return jsonify(ERR_SESS_TIMEOUT)
```</p>

<p>用途：生成一个有时间限制的签名，用于API 访问的验证码，如果过期，提醒用户重新登录</p>

<h3 id="第五节">一种较好的项目组织方式</h3>

<p><code>
▾ app/
    ▾ controlers/
        ▾ admin/                    #管理后台的蓝图控制器
            ▾ forms/                #表单限制文件
                __init__.py　　　　　
                xx.py　　　         # blueprint 文件
            __init__.py
            administrator.py
        ▾ api/                      # API 控制器
            __init__.py
        ▾ site/                     # 站点控制器
            __init__.py             # blueprint 文件
            xx.py
        __init__.py
        error.py
    ▸ models/         # SQLAlchemy 的各类模型
    ▸ static/         # 需要的静态资源，css, js, imgs
    ▾ templates/　　　# 前端页面，跟 controller 分类一一对应
        ▸ admin/
        ▸ error/
        ▸ site/
    ▸ utilities/　　　　#  功能函数
      __init__.py       #　初始化app需要的各种插件，比如 redis, db, 注册蓝图
run.py                  #　相当于 main 函数,创建 app, 执行app.run() 函数
settings.py             #　配置文件
</code></p>

<h3 id="第六节">BluePrint 的好 </h3>

<p>每个 Blueprint 就像独立的 Application, 可以管理自己的模板, 路由, 反向路由url_for, 甚至是静态文件，最后统一挂载到 Application 下。从头到尾都是 RestFul。</p>

<p>在创建 app (app/<strong>init</strong>.py) 的时候调用如下:</p>

<p><code>
from app.controllers.site.console import console 
app.register_blueprint(console, url_prefix='/console')
</code></p>

<p>视图文件 (app/controllers/site/console.py):</p>

<p><code>
console = BLueprint('console', __name__)
</code></p>

<h3 id="第七节">Json 返回</h3>

<p><code>
from flask import jsonify
return jsonify({'code': 0})
</code></p>

<h3 id="第八节">自定义出错页面</h3>

<p>```
@app.errorhandler(404)
def not_found(error):
    return render_template(‘404.html’), 404</p>

<p>@app.errorhandler(500)
def crash(error):
    return render_template(‘5xx.html’), 500
```</p>

<h3 id="第九节">WTF 跨站脚本防御</h3>

<p>Flask-WTF 能保护表单免受跨站请求伪造的攻击,恶意网站把请求发送到被攻击者已经登录的其他玩战会引发 CSRF 攻击</p>

<ul>
  <li>app config 文件中，开启 CSRF 开关并配置密钥</li>
</ul>

<p><code>
CSRF_ENABLED = True
SECRET_KEY = 'you-will-never-guess'
</code></p>

<ul>
  <li>表单的定义</li>
</ul>

<p><code>
from flask.ext.wtf import Form, TextField, BooleanField
from flask.ext.wtf import Required
class LoginForm(Form):
    openid = TextField('openid', validators = [Required()])
    remember_me = BooleanField('remember_me', default = False)
</code></p>

<ul>
  <li>页面渲染</li>
</ul>

<p><code>
&lt;form action="" method="post" name="login"&gt;
    form.hidden_tag()
    &lt;p&gt; Please enter your OpenID:form.openid(size=80)&lt;br&gt;&lt;/p&gt;
    &lt;p&gt;form.remember_me &lt;/p&gt;
    &lt;p&gt;&lt;input type="submit" value="Sign In"&gt;&lt;/p&gt;
&lt;/form&gt;
</code></p>

<ul>
  <li>控制器函数</li>
</ul>

<p><code>
@app.route('/login', methods = ['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        flash('Login requested for OpenID="' + form.openid.data))
        return redirect('/index')
    return render_template('login.html', title = 'Sign In',form = form)
</code></p>

<p>我们在配置中开启了CSRF(跨站伪造请求)功能，模板参数 form.hidden_tag() 会被替换成一个具有防止CSRF功能的隐藏表单字段。 在开启了CSRF功能后，所有模板的表单中都需要添加这个模板参数</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 使用 LDAP]]></title>
    <link href="http://zheng-ji.github.com/blog/2015/10/01/python-shi-yong-ldap/"/>
    <updated>2015-10-01T09:49:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2015/10/01/python-shi-yong-ldap</id>
    <content type="html"><![CDATA[<h2 id="section">写在开头</h2>

<p>过去的两个多星期，几位小伙伴同心协力完成一个自研的，类似<a href="http://pushover.net">pushover</a>的产品。感谢 Leader 的信任，让我在负责开发的同时也兼顾了一把项目经理。谢谢 IOS, Android 客户端的兄弟，设计师的支持，还有一位实习生，开心看到他的点滴成长。</p>

<p>提下背景，我们之前使用 <code>pushover</code> 来做报警推送，但是它对天朝用户不友好，Android 用户需要翻墙才能使用，有时候不稳定，体现为会收不到信息。pushove 需要付费。我们的受众不仅有程序汪，还有运营产品汪，他们需要一款更容易上手的推送软件，至少不需要番羽墙。于是自己开发一个很有必要。</p>

<p>为最大程度降低用户使用门槛，同时保证用户信息的安全，我们用了 LDAP 账户登陆，严格控制权限，以及 HTTPS 协议开发。下面提一提 LDAP 这个东西。</p>

<h2 id="ldap-">LDAP 是什么</h2>

<p><a href="https://zh.wikipedia.org/wiki/%E8%BD%BB%E5%9E%8B%E7%9B%AE%E5%BD%95%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE">LDAP维基百科</a></p>

<p>简单地讲，它是以目录树的方式存放账户信息。</p>

<p>这次项目中，我们不希望用户重新注册账户，而是采用原有的用户体系，这样对单点登录以及权限控制的好处不严而喻, LDAP 协议呼之欲出。</p>

<h2 id="virtualenv--python-ldap">virtualenv 下安装 python-ldap</h2>

<p>我们采用 Python 开发，这就需要 python-ldap 的帮助了, 记下安装笔记的好处是下次不用在此纠结太长时间。</p>

<p><code>
apt-get install libsasl2-dev python-dev libldap2-dev libssl-dev
pip install python-ldap
</code></p>

<h2 id="section-1">身份验证</h2>

<p><code>
# LDAP 服务的域名和端口
SERVER_NAME = 'xxxx'
SERVER_PORT = xxx
try:
    conn = ldap.open(SERVER_NAME, SERVER_PORT)  
    conn.protocol_version = ldap.VERSION3 #设置ldap协议版本 
    username = "user=xxx,dc=company,dc=com" #身份信息
    password = "xxx" #访问密码
    conn.simple_bind_s(username,password) # 开始绑定，验证成功的话不会抛出异常
except ldap.LDAPError, e: #捕获出错信息
    print e
</code></p>

<h2 id="section-2">一点感悟</h2>

<p>鄙人觉得，技术领导要带领项目成长, 除了有责任把控项目风险，推进项目进度。
还必须要花很多的心血在驾驭技术上,  身先士卒去调研可行性, 以及做技术攻关，
而非命令式地分配任务，让同事干活, 只问责结果。
否则很容易导致凝聚力不足,团队技术氛围不足，这样的团队易消极，也易滋生失败的项目。
然而在天朝, 很多人存在一个潜意识:写好代码是为了以后不写代码，这种阶级思想让我反感。</p>

<p>以前看过一个新闻, 硅谷在面试技术 VP ，仍然要求其在各位工程师面前手写代码，以此作为面试的重要环节, 不得不点赞。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[轻巧实时统计用户数]]></title>
    <link href="http://zheng-ji.github.com/blog/2015/06/11/qing-qiao-shi-shi-tong-ji-yong-hu-shu/"/>
    <updated>2015-06-11T23:14:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2015/06/11/qing-qiao-shi-shi-tong-ji-yong-hu-shu</id>
    <content type="html"><![CDATA[<h2 id="section">背景</h2>

<p>最近在优化一个短地址的统计服务，之前是使用 Cookie 来做统计每天的UV，而且这个需求是近乎实时的，
业务方需要每5分钟就能看到最新统计结果。但有些情况我们是取不到Cookie的，比如服务器对服务器的狂刷访问，那么UV就计算不准确，
是时候要改造方案了。</p>

<p>后来我用 IP+UserAgent 来识别用户，从而统计 UV。好了，接下来你会怎么做这个实时统计呢？</p>

<h2 id="section-1">两个方案的选择</h2>

<ul>
  <li>Plan A：</li>
</ul>

<p>将每天的 <code>IP+UA</code> 存进 Redis 的 Set 集合里，它会自动去重，然后计算该集合里元素的个数得到结果，此方案似乎不错，
但真的好吗？假如每天大概有200W个UV，1个用户标识<code>IP+UA</code>需要大概150个字节，那么大约要耗费300MB的内存。</p>

<p>觉得内存太宝贵，应该有更好的方法，想起了位运算， 于是就有了</p>

<ul>
  <li>Plan B:</li>
</ul>

<p>将 <code>IP+UA</code> 组合成的字符串哈希成一个数值，然后借助 Redis 的 BitSet 数据结构求出<code>UV</code>。以下是伪代码</p>

<p>```
conn = redis()
index = hash(UA+IP)
key = “xxx_2015-05-10”
conn.do(‘SETBIT’, key, index, 1) # 将该hash值对应的位赋值为1</p>

<p>realtime_uv = conn.do(‘BITCOUNT’, key) # 得到实时的uv
```</p>

<p>根据业务的情况，我的hash桶开了200W个位，大概需要消耗2M的内存，的确节约不少空间，位运算的效率也很快。
于是欣然选择 Plan B</p>

<h2 id="section-2">一些链接</h2>

<ul>
  <li><a href="https://redis.readthedocs.org/en/2.4/set.html">Redis Set</a></li>
  <li><a href="http://redis.io/commands/SETBIT">Redis BitSet</a></li>
  <li><a href="http://blog.nosqlfan.com/html/3501.html">NoSQLFan 一个文章</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实现一个智能提示框功能]]></title>
    <link href="http://zheng-ji.github.com/blog/2015/02/08/trie-suggestion/"/>
    <updated>2015-02-08T13:40:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2015/02/08/trie-suggestion</id>
    <content type="html"><![CDATA[<p>耗了3个夜晚出来的东西.</p>

<p>先上图吧：</p>

<p><img src="/images/2015/02/suggest.png"></p>

<p>是的，就是这样一个类似百度框的联想提升功能，让我纠结了几个晚上，在实现成功的那一瞬间，着实感受到编程之美。很享受为了一个小idea折腾的酣畅淋漓的过程。</p>

<p>起因: 在公司<code>GitLab</code>看到有这人对内部管理系统提出了这个需求，但是一直没有被<code>close</code>, 我觉得应该挺有趣的，好奇心驱动下就开始搞了。</p>

<p>如果仅仅是实现这个需求，应该有很多种</p>

<ul>
  <li>方法一：使用一个hash,将关键字填入key，如果采用此法，数据量大的时候估计堪忧，以一个汉字2个Byte计算的话，1kw个词条，1个词条10个词语的话需要占用大于200M内存。</li>
  <li>方法二：前缀匹配，那么应该怎么选择数据结构,朴素的做法是O(N^N),我们肯定采用复杂度较优的Trie树  O(1)</li>
  <li>方法三：Radix Tree 据说这个是linux cache的一个算法。看了几个小时，真心复杂，不得不佩服内核开发者！</li>
</ul>

<h3 id="trie">讲一讲<code>trie</code>树吧</h3>

<p><img src="/images/2015/02/triestruct.png"></p>

<ul>
  <li>根节点不包含字符，除根节点外的每一个子节点都包含一个字符。</li>
  <li>根节点到某一节点，路径上经过的字符连接起来，就是该节点对应的字符串。</li>
  <li>每个单词的公共前缀作为一个字符节点保存。</li>
  <li>叶子节点的指针是空的</li>
</ul>

<p>以下是具体的数据结构代码</p>

<p><code>
type Node struct {
    Link     map[string]*Node  #指针
    Key      string                     #每个节点的字符
    IsLeaf   bool                       #是否叶子节点 
    Weight   float64                    #权重
    LongWord string                     #从根节点到该节点的长字符
}
</code></p>

<p>围绕这个数据结构做了
构建树，删除节点，添加节点，获取子节点等</p>

<h3 id="section">知识铺垫：</h3>
<p>在用 Go 语言处理中文字符的时候，需要特别使用 []rune数组，看以下示范代码就知道了,他把中文处理成1个字符表现的编码方式了。正式我们下列处理Trie需要用到的。</p>

<p>```
package main
import “fmt”</p>

<p>func main () {
    m_str := “编程”
    fmt.Println(“fmt:”, m_str)
    m_str_rune := []rune(m_str)
    fmt.Println(“fmt:”, m_str_rune)
    m_str_byte := []byte(m_str)
    fmt.Println(“fmt:”, m_str_byte)
}</p>

<p>$ ./test_rune
fmt: 编程
fmt: [32534 31243]
fmt: [231 188 150 231 168 139]
```</p>

<h3 id="section-1">测试结果：</h3>
<p>导入100W条词条,搜索的反应是瞬秒，1ms返回响应，在4G的机器上，整个程序占用内存0.3%。</p>

<hr />

<p>每个成熟的互联网产品，背后都是工程师耗费一点一滴思维的结晶构建而成的。对待技术不得不敬畏。</p>

<p><a href="https://github.com/zheng-ji/trietips">代码</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go Protobuf]]></title>
    <link href="http://zheng-ji.github.com/blog/2014/07/12/goan-zhuang-protobuf/"/>
    <updated>2014-07-12T17:39:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2014/07/12/goan-zhuang-protobuf</id>
    <content type="html"><![CDATA[<p>protobuf 是谷歌出品的，质量就无需质疑了，广泛运用于工业界
优点简而言之是：</p>

<ul>
  <li>二进制，速度快，便于拓展；</li>
  <li>自动生成代码接口，支持多语言</li>
</ul>

<p>对于第一点, 貌似优秀的开源代码没这么干都不好意思开放。</p>

<h3 id="section">安装</h3>

<p>比较蛋疼,折腾一小段时间。</p>

<p>```
go get code.google.com/p/goprotobuf/{proto, protoc-gen-go}</p>

<p>go install code.google.com/p/goprotobuf/proto</p>

<p>sudo apt-get install protobuf-compiler
```</p>

<h3 id="section-1">使用</h3>

<p>是在项目内部新建一个proto.文件, 然后执行</p>

<p><code>
protoc --go_out=. xxx.proto
</code></p>

]]></content>
  </entry>
  
</feed>
