<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programe | 织网]]></title>
  <link href="http://zheng-ji.github.com/blog/categories/programe/atom.xml" rel="self"/>
  <link href="http://zheng-ji.github.com/"/>
  <updated>2016-09-28T08:33:50+08:00</updated>
  <id>http://zheng-ji.github.com/</id>
  <author>
    <name><![CDATA[zheng-ji]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[记一次使用 redis 协议诡异的bug]]></title>
    <link href="http://zheng-ji.github.com/blog/2016/09/28/ji-yi-ci-redis-server-bug/"/>
    <updated>2016-09-28T08:21:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2016/09/28/ji-yi-ci-redis-server-bug</id>
    <content type="html"><![CDATA[<p>记录昨天定位一个诡异 bug 的过程，我耗费了不少精力，你若有兴趣，请带着一点耐心看完它。</p>

<p>我们使用 <a href="https://github.com/youmi/go-redis-server">go-redis-server</a> 开发具有 redis 接口的服务。 按照文档，我们实现了如下接口，其背后访问的是 AWS 的 Dynamodb, 我们的服务也开发了监控接口，以供我们这些程序狗知道它发生了什么。</p>

<p><code>
func (handler *RedisHandler) Get(key string) (result string, err error)
func (handler *RedisHandler) Set(key string, val string) (err error)
func (handler *RedisHandler) Del(key string) (count int, err error)
</code></p>

<p>这样，我们就能通过redis客户端来执行 Get，Set，Del 操作。</p>

<h3 id="section">问题背景</h3>

<p>我在批量写入几千条数据时，通过监控接口，我看到服务突然卡住的样子，没有 Get，Set的统计信息了。但我能肯定的是客户端一直有数据在往服务写入，或者读写。
同时从 AWS 监控得到的反馈是 Dynamodb 使用超过预设值，我调高了读写预设值，重启服务，就恢复可用（重启大法好）。
程序试运行十多天，只发生过一次异常，之后再无重现。
这个事情没有搞清楚，就成为我一个心结。</p>

<h3 id="section-1">重现问题</h3>

<p>我们来看看代码</p>

<p>```
func (handler *RedisHandler) 
Set(key string, val string) (err error) {
	…</p>

<pre><code>m, err := JSONToMap(val)
_, err = table.PutItem(m)
if err != nil {
	log.Log.Errorf("PutItem failed, 
	table: %s, primary key: %s, value: %+v, 
	err: %s", 
	tableName, primaryVal, m, err.Error())
	return
}
return } ```
</code></pre>

<p>Set接口，简单的将数据写入dynamodb，dynamodb 如果异常就返回错误，然后通过redis协议返回给客户端。</p>

<p>我很大程度确定那时候是因为 AWS Dynamodb 的异常导致这个错误的。除非这个巧合太牛逼了，难道 go-redis-server 接口不支持返回错误不成吗？这个猜想很快就被我们用实验否定了。</p>

<p>我想重新触发 AWS Dynamodb 返回写容量超标的错误，测试了一阵子，并不容易重现。有点沮丧，这个时候我回忆起 aws-go-sdk的特点，如果给dynamodb 字段 赋予空值，是会有异常返回的，
类似如下：</p>

<p><code>
ValidationException: One or more parameter values were invalid:
An AttributeValue may not contain an empty string
	status code: 400
</code></p>

<p>空值的测试明显容易制造。我在本地也开启服务，端口是1234，用pyredis 作为客户端做测试</p>

<p>测试脚本</p>

<p>```
import redis
import json
import random
r = redis.Redis(host=’localhost’,port=1234,db=0)</p>

<p>table_name = ‘test’
primary_key = ‘a’</p>

<p>i = 0
while True:
    if i &gt; 2:
        break
    data = {
        ‘a’: str(random.random()),
        ‘b’: ‘’,
    }
    key = ‘{0}:{1}:{2}’.format(table_name, primary_key, data[primary_key])
    value = json.dumps(data)
    r.set(key, value)
    i = i + 1
```</p>

<p>发现测试程序卡在终端，一动不动，strace 测试程序</p>

<p><code>
$ sudo strace -p 22404
Process 22404 attached
recvfrom(3,
</code></p>

<p>感觉像是在等待服务器返回，但是等不到回报的样子。</p>

<h3 id="section-2">试着解决问题</h3>

<p>难道 go-redis-server 这个框架有猫腻，我就开始了一下午的看源码之旅。不得不说源码写的真好。回头看我们出错的代码片段，我试着修改 err信息，修改成自己定义的错误字符串。</p>

<p>```
func (handler *RedisHandler) Set(key string, val string) (err error) {
	…</p>

<pre><code>m, err := JSONToMap(val)
_, err = table.PutItem(m)
if err != nil {
	err = errors.New("I am a Custom Error")
	return
}
return } ```
</code></pre>

<p>再次执行测试脚本，这一次。2条测试数据很快就执行结束，并无阻塞。
好像看到了一丝曙光：error 内容的不一样，导致不一样的结果。类型一样，那么我能怀疑的就是格式，或者长度了。</p>

<p>```
AWS 错误信息的格式：
ValidationException: One or more parameter values were invalid:
An AttributeValue may not contain an empty string
	status code: 400</p>

<p>我自定义错误信息的格式：
I am a Custom Error
```</p>

<p>我特意加长了自定义错误的长度，结果也是能顺利执行不阻塞客户端。但是我给自定义错误字符串加入了换行符，果然客户端再次测试会出现阻塞。当出现错误的时候，源码中是调用了 ErrorReply.WriteTo 这个函数，特别的。返回错误的协议格式是</p>

<blockquote>
  <p>第一个字节将是“-”,并以CR + LF 结尾</p>
</blockquote>

<p>配合源码，以下是 go-redis-server 最核心的逻辑调度代码。</p>

<p><code>
for {
	request, err := parseRequest(conn)
	if err != nil {
		return err
	}
		request.Host = clientAddr
		request.ClientChan = clientChan
		reply, err := srv.Apply(request)
		if err != nil {
			return err
		}
		if _, err = reply.WriteTo(conn); err != nil {
			return err
		}
	}
	return nil
}
func (er *ErrorReply) WriteTo(w io.Writer) (int64, error) {
	n, err := w.Write([]byte("-" + er.code + " " + er.message + "\r\n"))
	return int64(n), err
}
</code></p>

<p>从 <a href="http://redis.cn/topics/protocol.html">Redis协议官方文档</a>，可以确定客户端与服务器端之间传输的每个 Redis 命令或者数据都以 <code>\r\n</code> 结尾。 我们的错误信息中间杀出了 <code>\n</code>，导致协议错乱，redis 客户端不能理解协议，就阻塞了。</p>

<h3 id="section-3">一点感悟</h3>

<ul>
  <li>
    <p>以后我们使用 go-redis-server 的服务时候，要记得检查返回的字符串或者错误信息有没有包含换行符，如果有，最好做一次过滤替换。</p>
  </li>
  <li>
    <p>出现这个bug,我和同事都觉得不可思议，非常神奇。在没有其他直观线索的条件下，阅读使用的库的源码，并在源码加上一些输出验证语言加以辅助，收到了效果，的确需要一些耐心。但我觉得是值得的。</p>
  </li>
  <li>
    <p>李笑来说有效阅读就是精度，这次阅读代码过程中我还有意外的收获，我发现了reflect的妙用，以及函数注册在框架的用法，读完觉得很满足开心的样子，值得再记录一番。</p>
  </li>
</ul>

<hr />

<p>附链接：</p>

<ul>
  <li><a href="http://redis.cn/topics/protocol.html">Redis官方协议</a></li>
  <li><a href="https://github.com/youmi/go-redis-server">go-redis-server</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CuckooFilter，BloomFilter的优化]]></title>
    <link href="http://zheng-ji.github.com/blog/2016/08/01/cuckoofilter/"/>
    <updated>2016-08-01T19:48:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2016/08/01/cuckoofilter</id>
    <content type="html"><![CDATA[<p>面对海量数据，我们需要一个索引数据结构，用来帮助查询，快速判断数据记录是否存在，这类数据结构叫过滤器，常用的选择是 <code>Bloom Filter</code>. 而 <code>Cuckoo Filter</code> 是它的优化变种。借此也用 Golang 实践了这个<a href="https://github.com/zheng-ji/goCuckoo">算法</a>。</p>

<p><img src="https://cloud.githubusercontent.com/assets/1414745/17084380/8c3a4896-51ee-11e6-869e-b087226cc5ce.jpg" alt="goCuckoo" /></p>

<p><code>Bloom Filter</code> 的位图模式有两个问题：</p>

<ul>
  <li>误报，它能判断元素一定不存在，但只能判断可能存在，因为存在其它元素被映射到部分相同位上，导致该位置1，那么一个不存在的元素可能会被误报成存在；</li>
  <li>漏报，如果删除了某个元素，导致该映射位被置0，那么本来存在的元素会被漏报成不存在。 </li>
</ul>

<p><code>Cuckoo Filter</code>，可以确保该元素存在的必然性，又可以在不违背此前提下删除任意元素，仅仅比 <code>Bloom Filter</code> 牺牲了微量空间效率。 它的的数据模型: </p>

<ul>
  <li>每个元素对应两个哈希算法，在哈希碰撞时会启用备用哈希算法。</li>
  <li>每一个桶是有4路的，每个槽对应一个指纹。</li>
</ul>

<p><img src="https://cloud.githubusercontent.com/assets/1414745/17103421/c97635e0-52b0-11e6-83ac-1b1fdbb5d31c.png" alt="model" /></p>

<h2 id="feature">Feature</h2>

<ul>
  <li>支持删除操作</li>
  <li>支持快速查找，支持 O(1) 查找速度</li>
  <li>高效的空间利用，四路槽的表，可以有95% 的空间利用率</li>
  <li>可替代布隆过滤器</li>
</ul>

<h2 id="installation">Installation</h2>

<p><code>
go get github.com/zheng-ji/goCuckoo
</code></p>

<h2 id="example">Example</h2>

<p>```go
import (
	“fmt”
	“github.com/zheng-ji/goCuckoo”
)</p>

<p>func main() {
    // speicify capacity 
	filter := cuckoo.NewCuckooFilter(10000)</p>

<pre><code>filter.Insert([]byte("zheng-ji"))
filter.Insert([]byte("stupid"))
filter.Insert([]byte("coder"))

if filter.Find([]byte("stupid")) {
	fmt.Println("exist")
} else {
	fmt.Println("Not exist")
}

filter.Del([]byte("stupid"))
filter.Println(filter.Size()) } ```
</code></pre>

<h2 id="section">参考</h2>

<ul>
  <li><a href="http://www.cs.cmu.edu/~binfan/papers/conext14_cuckoofilter.pdf">CMU Paper</a></li>
  <li><a href="http://www.cs.cmu.edu/~binfan/papers/conext14_cuckoofilter.pptx">CMU PPT</a></li>
  <li><a href="http://coolshell.cn/articles/17225.html">CoolShell Article</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Celery的Crontab实践]]></title>
    <link href="http://zheng-ji.github.com/blog/2016/07/23/celeryde-crontabshi-jian/"/>
    <updated>2016-07-23T20:19:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2016/07/23/celeryde-crontabshi-jian</id>
    <content type="html"><![CDATA[<p>有时候我们需要处理耗时的操作，同时又要保持较快的响应速度，就需要借助异步队列的帮助。Celery 作为异步队列服务，想必是很多人和我一样的选择。用法在官方文档也详细介绍，不再赘述。</p>

<p>这次想记录的是用 Celery 来实现定时任务。这里也有一点点坑。</p>

<p>以下是 <code>main.py</code> 的内容</p>

<p>```py
from celery import Celery
from lib import distribute
from celery.schedules import crontab</p>

<p>app = distribute.app
app.conf.update(
    CELERYBEAT_SCHEDULE = {
        ‘every-minute’: {
            ‘task’: ‘test_cron’,
            ‘schedule’: crontab(minute=”*”),
            ‘args’: (16, 13),
        }
    },
    CELERY_INCLUDE=(“apps.tasks”,)
)
if <strong>name</strong> == ‘<strong>main</strong>’:
    app.start()
```</p>

<p>实际工作单元,我放在 apps 目录下的 <code>tasks.py</code> 文件中</p>

<p><code>py
from lib.distribute import app
@app.task(name="test_cron")
def mul(x, y):
    return x * y
</code></p>

<p>上述是一个简单的 Crontab 应用，它仅需要以下命令就能执行,
其中  <code>--beat</code> 表示 crontab 的应用</p>

<p><code>
python main.py worker --beat -l info
</code></p>

<p>起初我想把异步队列和定时任务放在一起,就加上了一句 CELERY_QUEUES 的配置</p>

<p><code>py
app.conf.update(
    // 添加的部分
    CELERY_QUEUES=(
        Queue(
          'test', Exchange('test_exchange'),
           routing_key='test_queue'
        ),
    ),
    CELERYBEAT_SCHEDULE = {
        'every-minute': {
            'task': 'test_cron',
            'schedule': crontab(minute="*"),
            'args': (16, 13),
        }
    },
    CELERY_INCLUDE=("apps.tasks",)
)
</code></p>

<p>同样用上述命令开启worker，发现这个时候 Crontab 不能工作了，后来看到官方的文档：</p>

<blockquote>
  <p>celery beat and celery worker as separate services instead. </p>
</blockquote>

<p>也就是说 Celery 的 Beat 需要和其他异步worker 分开，单独执行。</p>

<p>相关代码<a href="https://github.com/zheng-ji/ToyCollection/tree/master/celery_proj">链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记录使用 Flask 的点滴]]></title>
    <link href="http://zheng-ji.github.com/blog/2015/10/06/ji-lu-shi-yong-flaskde-dian-di/"/>
    <updated>2015-10-06T13:21:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2015/10/06/ji-lu-shi-yong-flaskde-dian-di</id>
    <content type="html"><![CDATA[<p>喜欢 Flask 经典的 RestFul 设计风格，以及它与 Gevent 的优雅结合，可以帮助我们轻松构建异步非阻塞应用，烂笔头记下一些较好的实践。</p>

<ul>
  <li><a href="#第一节">消息反馈</a></li>
  <li><a href="#第二节">Flask 上下文</a></li>
  <li><a href="#第三节">注册 JinJia 模板过滤器</a></li>
  <li><a href="#第四节">itsdangerous 生成过期时间 Json 签名</a></li>
  <li><a href="#第五节">一种较好的项目组织方式</a></li>
  <li><a href="#第六节">BluePrint 的好</a></li>
  <li><a href="#第七节">Json 返回</a></li>
  <li><a href="#第八节">自定义出错页面</a></li>
  <li><a href="#第九节">WTF 跨站脚本防御</a></li>
</ul>

<h3 id="第一节">消息反馈</h3>

<p>Flask 提供了一个非常简单的方法来使用闪现系统向用户反馈信息。
闪现系统使得在一个请求结束的时候记录一个信息，然后在且仅仅在下一个请求中访问这个数据。这通常配合一个布局模板实现</p>

<p><a href="http://docs.jinkan.org/docs/flask/patterns/flashing.html">文档链接</a></p>

<p>```
# 视图函数需要调用
flash(‘your response message for user’)</p>

<h1 id="section">前端页面调用</h1>
<p>for message in get_flashed_messages()
就可以输出反馈信息
```</p>

<h3 id="第二节">Flask 上下文</h3>

<p>有两种上下文：程序上下文，请求上下文</p>

<ul>
  <li>current_app： 程序级别上下文，当前激活程序的实例。</li>
  <li>g: 请求级别的上下文</li>
  <li>request: 是请求级别的上下文，封装了客户端发出的 Http 请求中的内容</li>
  <li>session: 用户会话，用于存储请求之间需要记住的键值对</li>
</ul>

<h3 id="第三节">注册 JinJia 模板过滤</h3>

<p>```
def reverse_filter(s):
    return s[::-1]</p>

<p>app.jinja_env.filters[‘reverse’] = reverse_filter
```</p>

<h3 id="第四节">itsdangerous 生成过期时间 Json 签名</h3>

<p>```
serialaizer = Serializer(SECRET_KEY, expires_in=EXPIRES)
info = {‘id’:’xxx’}
session = serialaizer.dumps(info)</p>

<h1 id="session-">判断 session 时间</h1>
<p>info = None
try:
    info = serialaizer.loads(session)
except Exception:
    return jsonify(ERR_SESS_TIMEOUT)
```</p>

<p>用途：生成一个有时间限制的签名，用于API 访问的验证码，如果过期，提醒用户重新登录</p>

<h3 id="第五节">一种较好的项目组织方式</h3>

<p><code>
▾ app/
    ▾ controlers/
        ▾ admin/                    #管理后台的蓝图控制器
            ▾ forms/                #表单限制文件
                __init__.py　　　　　
                xx.py　　　         # blueprint 文件
            __init__.py
            administrator.py
        ▾ api/                      # API 控制器
            __init__.py
        ▾ site/                     # 站点控制器
            __init__.py             # blueprint 文件
            xx.py
        __init__.py
        error.py
    ▸ models/         # SQLAlchemy 的各类模型
    ▸ static/         # 需要的静态资源，css, js, imgs
    ▾ templates/　　　# 前端页面，跟 controller 分类一一对应
        ▸ admin/
        ▸ error/
        ▸ site/
    ▸ utilities/　　　　#  功能函数
      __init__.py       #　初始化app需要的各种插件，比如 redis, db, 注册蓝图
run.py                  #　相当于 main 函数,创建 app, 执行app.run() 函数
settings.py             #　配置文件
</code></p>

<h3 id="第六节">BluePrint 的好 </h3>

<p>每个 Blueprint 就像独立的 Application, 可以管理自己的模板, 路由, 反向路由url_for, 甚至是静态文件，最后统一挂载到 Application 下。从头到尾都是 RestFul。</p>

<p>在创建 app (app/<strong>init</strong>.py) 的时候调用如下:</p>

<p><code>
from app.controllers.site.console import console 
app.register_blueprint(console, url_prefix='/console')
</code></p>

<p>视图文件 (app/controllers/site/console.py):</p>

<p><code>
console = BLueprint('console', __name__)
</code></p>

<h3 id="第七节">Json 返回</h3>

<p><code>
from flask import jsonify
return jsonify({'code': 0})
</code></p>

<h3 id="第八节">自定义出错页面</h3>

<p>```
@app.errorhandler(404)
def not_found(error):
    return render_template(‘404.html’), 404</p>

<p>@app.errorhandler(500)
def crash(error):
    return render_template(‘5xx.html’), 500
```</p>

<h3 id="第九节">WTF 跨站脚本防御</h3>

<p>Flask-WTF 能保护表单免受跨站请求伪造的攻击,恶意网站把请求发送到被攻击者已经登录的其他玩战会引发 CSRF 攻击</p>

<ul>
  <li>app config 文件中，开启 CSRF 开关并配置密钥</li>
</ul>

<p><code>
CSRF_ENABLED = True
SECRET_KEY = 'you-will-never-guess'
</code></p>

<ul>
  <li>表单的定义</li>
</ul>

<p><code>
from flask.ext.wtf import Form, TextField, BooleanField
from flask.ext.wtf import Required
class LoginForm(Form):
    openid = TextField('openid', validators = [Required()])
    remember_me = BooleanField('remember_me', default = False)
</code></p>

<ul>
  <li>页面渲染</li>
</ul>

<p><code>
&lt;form action="" method="post" name="login"&gt;
    form.hidden_tag()
    &lt;p&gt; Please enter your OpenID:form.openid(size=80)&lt;br&gt;&lt;/p&gt;
    &lt;p&gt;form.remember_me &lt;/p&gt;
    &lt;p&gt;&lt;input type="submit" value="Sign In"&gt;&lt;/p&gt;
&lt;/form&gt;
</code></p>

<ul>
  <li>控制器函数</li>
</ul>

<p><code>
@app.route('/login', methods = ['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        flash('Login requested for OpenID="' + form.openid.data))
        return redirect('/index')
    return render_template('login.html', title = 'Sign In',form = form)
</code></p>

<p>我们在配置中开启了CSRF(跨站伪造请求)功能，模板参数 form.hidden_tag() 会被替换成一个具有防止CSRF功能的隐藏表单字段。 在开启了CSRF功能后，所有模板的表单中都需要添加这个模板参数</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 使用 LDAP]]></title>
    <link href="http://zheng-ji.github.com/blog/2015/10/01/python-shi-yong-ldap/"/>
    <updated>2015-10-01T09:49:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2015/10/01/python-shi-yong-ldap</id>
    <content type="html"><![CDATA[<h2 id="section">写在开头</h2>

<p>过去的两个多星期，几位小伙伴同心协力完成一个自研的，类似<a href="http://pushover.net">pushover</a>的产品。感谢 Leader 的信任，让我在负责开发的同时也兼顾了一把项目经理。谢谢 IOS, Android 客户端的兄弟，设计师的支持，还有一位实习生，开心看到他的点滴成长。</p>

<p>提下背景，我们之前使用 <code>pushover</code> 来做报警推送，但是它对天朝用户不友好，Android 用户需要翻墙才能使用，有时候不稳定，体现为会收不到信息。pushove 需要付费。我们的受众不仅有程序汪，还有运营产品汪，他们需要一款更容易上手的推送软件，至少不需要番羽墙。于是自己开发一个很有必要。</p>

<p>为最大程度降低用户使用门槛，同时保证用户信息的安全，我们用了 LDAP 账户登陆，严格控制权限，以及 HTTPS 协议开发。下面提一提 LDAP 这个东西。</p>

<h2 id="ldap-">LDAP 是什么</h2>

<p><a href="https://zh.wikipedia.org/wiki/%E8%BD%BB%E5%9E%8B%E7%9B%AE%E5%BD%95%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE">LDAP维基百科</a></p>

<p>简单地讲，它是以目录树的方式存放账户信息。</p>

<p>这次项目中，我们不希望用户重新注册账户，而是采用原有的用户体系，这样对单点登录以及权限控制的好处不严而喻, LDAP 协议呼之欲出。</p>

<h2 id="virtualenv--python-ldap">virtualenv 下安装 python-ldap</h2>

<p>我们采用 Python 开发，这就需要 python-ldap 的帮助了, 记下安装笔记的好处是下次不用在此纠结太长时间。</p>

<p><code>
apt-get install libsasl2-dev python-dev libldap2-dev libssl-dev
pip install python-ldap
</code></p>

<h2 id="section-1">身份验证</h2>

<p><code>
# LDAP 服务的域名和端口
SERVER_NAME = 'xxxx'
SERVER_PORT = xxx
try:
    conn = ldap.open(SERVER_NAME, SERVER_PORT)  
    conn.protocol_version = ldap.VERSION3 #设置ldap协议版本 
    username = "user=xxx,dc=company,dc=com" #身份信息
    password = "xxx" #访问密码
    conn.simple_bind_s(username,password) # 开始绑定，验证成功的话不会抛出异常
except ldap.LDAPError, e: #捕获出错信息
    print e
</code></p>

<h2 id="section-2">一点感悟</h2>

<p>鄙人觉得，技术领导要带领项目成长, 除了有责任把控项目风险，推进项目进度。
还必须要花很多的心血在驾驭技术上,  身先士卒去调研可行性, 以及做技术攻关，
而非命令式地分配任务，让同事干活, 只问责结果。
否则很容易导致凝聚力不足,团队技术氛围不足，这样的团队易消极，也易滋生失败的项目。
然而在天朝, 很多人存在一个潜意识:写好代码是为了以后不写代码，这种阶级思想让我反感。</p>

<p>以前看过一个新闻, 硅谷在面试技术 VP ，仍然要求其在各位工程师面前手写代码，以此作为面试的重要环节, 不得不点赞。</p>

]]></content>
  </entry>
  
</feed>
