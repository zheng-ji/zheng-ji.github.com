<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programe | 织网]]></title>
  <link href="http://zheng-ji.github.com/blog/categories/programe/atom.xml" rel="self"/>
  <link href="http://zheng-ji.github.com/"/>
  <updated>2015-04-05T20:31:14+08:00</updated>
  <id>http://zheng-ji.github.com/</id>
  <author>
    <name><![CDATA[zheng-ji]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[实现一个智能提示框功能]]></title>
    <link href="http://zheng-ji.github.com/blog/2015/02/08/trie-suggestion/"/>
    <updated>2015-02-08T13:40:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2015/02/08/trie-suggestion</id>
    <content type="html"><![CDATA[<p>耗了3个夜晚出来的东西.</p>

<p>先上图吧：</p>

<p><img src="/images/2015/02/suggest.png"></p>

<p>是的，就是这样一个类似百度框的联想提升功能，让我纠结了几个晚上，在实现成功的那一瞬间，着实感受到编程之美。很享受为了一个小idea折腾的酣畅淋漓的过程。</p>

<p>起因: 在公司<code>GitLab</code>看到有这人对内部管理系统提出了这个需求，但是一直没有被<code>close</code>, 我觉得应该挺有趣的，好奇心驱动下就开始搞了。</p>

<p>如果仅仅是实现这个需求，应该有很多种</p>

<ul>
  <li>方法一：使用一个hash,将关键字填入key，如果采用此法，数据量大的时候估计堪忧，以一个汉字2个Byte计算的话，1kw个词条，1个词条10个词语的话需要占用大于200M内存。</li>
  <li>方法二：前缀匹配，那么应该怎么选择数据结构,朴素的做法是O(N^N),我们肯定采用复杂度较优的Trie树  O(1)</li>
  <li>方法三：Radix Tree 据说这个是linux cache的一个算法。看了几个小时，真心复杂，不得不佩服内核开发者！</li>
</ul>

<h3 id="trie">讲一讲<code>trie</code>树吧</h3>

<p><img src="/images/2015/02/triestruct.png"></p>

<ul>
  <li>根节点不包含字符，除根节点外的每一个子节点都包含一个字符。</li>
  <li>根节点到某一节点，路径上经过的字符连接起来，就是该节点对应的字符串。</li>
  <li>每个单词的公共前缀作为一个字符节点保存。</li>
  <li>叶子节点的指针是空的</li>
</ul>

<p>以下是具体的数据结构代码</p>

<p><code>
type Node struct {
    Link     map[string]*Node  #指针
    Key      string                     #每个节点的字符
    IsLeaf   bool                       #是否叶子节点 
    Weight   float64                    #权重
    LongWord string                     #从根节点到该节点的长字符
}
</code></p>

<p>围绕这个数据结构做了
构建树，删除节点，添加节点，获取子节点等</p>

<h3 id="section">知识铺垫：</h3>
<p>在用 Go 语言处理中文字符的时候，需要特别使用 []rune数组，看以下示范代码就知道了,他把中文处理成1个字符表现的编码方式了。正式我们下列处理Trie需要用到的。</p>

<p>```
package main
import “fmt”</p>

<p>func main () {
    m_str := “编程”
    fmt.Println(“fmt:”, m_str)
    m_str_rune := []rune(m_str)
    fmt.Println(“fmt:”, m_str_rune)
    m_str_byte := []byte(m_str)
    fmt.Println(“fmt:”, m_str_byte)
}</p>

<p>$ ./test_rune
fmt: 编程
fmt: [32534 31243]
fmt: [231 188 150 231 168 139]
```</p>

<h3 id="section-1">测试结果：</h3>
<p>导入100W条词条,搜索的反应是瞬秒，1ms返回响应，在4G的机器上，整个程序占用内存0.3%。</p>

<hr />

<p>每个成熟的互联网产品，背后都是工程师耗费一点一滴思维的结晶构建而成的。对待技术不得不敬畏。</p>

<p><a href="https://github.com/zheng-ji/trietips">代码</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[go安装protobuf]]></title>
    <link href="http://zheng-ji.github.com/blog/2014/07/12/goan-zhuang-protobuf/"/>
    <updated>2014-07-12T17:39:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2014/07/12/goan-zhuang-protobuf</id>
    <content type="html"><![CDATA[<p>protobuf是谷歌出品的，质量就无需质疑了，广泛运用于工业界
优点简而言之是：</p>

<ul>
  <li>二进制，速度快，便于拓展；</li>
  <li>自动生成代码接口，支持多语言</li>
</ul>

<p>对于第一点, 貌似优秀的开源代码没这么干都不好意思开放。</p>

<p>关于 <code>protobuf</code> 的使用方法网上资料丰富。记录下使用 golang 玩protobuf的东西</p>

<p>安装, 比较蛋疼,折腾一小段时间。</p>

<p>```
go get code.google.com/p/goprotobuf/{proto, protoc-gen-go}</p>

<p>go install code.google.com/p/goprotobuf/proto</p>

<p>sudo apt-get install protobuf-compiler
```</p>

<p>使用的时, 是在项目内部新建一个proto.文件, 然后执行</p>

<p><code>
protoc --go_out=. xxx.proto
</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[制作setup.py]]></title>
    <link href="http://zheng-ji.github.com/blog/2014/05/03/make-setup-dot-py/"/>
    <updated>2014-05-03T11:52:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2014/05/03/make-setup-dot-py</id>
    <content type="html"><![CDATA[<p>做好一个python module 之后，可以把源代码包含进项目中。OK，但是如果有很多依赖项目的话就不好管理了，这个时候我们用 setuptools 工具来安装到系统的包。</p>

<p>以下给出一个 demo </p>

<p><code>
mkdir hacker
vim foo.py
</code></p>

<p>编辑以下内容</p>

<p><code>python
class Hacker():
    def __init__(self):
        self.motto = "No evil, Be Hacker"
    def printMotto(self):
        print self.motto
</code></p>

<p>开始编写 setup.py, 也许是为了知识产权保护，里面按照规矩会让作者填上资料。</p>

<p><code>python
from distutils.core import setup
setup(name='Hacker',
        version='1.0',
        description='be hake or be hacked',
        author='zheng-ji',
        author_email='zhengji91@gmail.com',
        url='http://zheng-ji.info',
        py_modules=['foo'],
        install_requires=["requests"]
     )
</code></p>

<p>好了，这个时候执行,</p>

<p><code>
sudo python setup.py install
</code></p>

<p>该命令，会把模块复制到 <code>/usr/lib/python2.7/</code> 下面. 之后可以直接 import foo, 使用该模块。</p>

<p>删除的话，就得蛋疼去 <code>/usr/lib/python2.7/</code> 手动删除,在 mac 里面是 <code>/Library/Python/2.7/site-packages</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mac 安装Go]]></title>
    <link href="http://zheng-ji.github.com/blog/2014/05/03/mac-an-zhuang-go/"/>
    <updated>2014-05-03T09:32:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2014/05/03/mac-an-zhuang-go</id>
    <content type="html"><![CDATA[<hr />
<p>之前是在 Ubuntu 配置Go 的环境，换了 Mac 后，也来折腾一番，其实很简单。</p>

<p>修改 <code>~.zshrc</code>,添加以下环境变量</p>

<p><code>
export GOROOT=$HOME/go
export GOBIN=$GOROOT/bin
export PATH=$PATH:$GOBIN
</code></p>

<p>开始安装,耗时有点久
保证你的电脑安装有 hg, 如果没有,请执行 </p>

<p><code>
sudo easy_install mercurial
</code></p>

<p><code>
hg clone -u release https://code.google.com/p/go
cd go/src
./all.bash
</code></p>

<p>开始检验, 执行 go , 出现一系列 Usage信息就算通过了 ：）。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ Expect 与系统自动交互]]></title>
    <link href="http://zheng-ji.github.com/blog/2014/03/13/expect-yu-xi-tong-zi-dong-jiao-hu/"/>
    <updated>2014-03-13T23:05:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2014/03/13/expect-yu-xi-tong-zi-dong-jiao-hu</id>
    <content type="html"><![CDATA[<p>在<code>linux</code>下 做一些操作的时候，比如使用 <em>scp</em>, <em>telnet</em> 等命令，通常系统会让你输入密码，你只好乖乖地停下来输入。倘若你希望批量执行一个脚本中得所有命令，系统执行到某句命令的时候停下来让你输入密码，就比较囧了。于是你感慨，如果是一气呵成多省事啊。</p>

<p>这个时候，你可以使用 <em>expect</em> 语言帮我们解决问题。</p>

<h3 id="section">官方定义</h3>
<blockquote>
  <p>Expect是一个用来实现自动交互功能的软件套件 (Expect [is a] software suite for automating interactive tools)</p>
</blockquote>

<p>expect 是 <a href="http://en.wikipedia.org/wiki/Don_Libes">Don Libes</a> 编写的免费编程工具语言, 由expect-send对组成：</p>

<p>expect等待输出中输出特定的字符，通常是一个提示符，然后发送特定的响应。</p>

<hr />

<p>先来个 helloworld, 注意需要在exp脚本前面加上 <code>#!/usr/bin/expect</code></p>

<p><code>sh
#!/usr/bin/expect
send_user "hello world"
</code></p>

<p>这里的 send_user 类似 echo </p>

<h3 id="section-1">常见用法</h3>

<p><code>
set i 0    
set user [lindex $argv 0]
set timeout 300
set i 0
while { $i &lt; 10 } {
    puts $i;
    incr i;
}
</code></p>

<p>以上分别是:</p>

<ul>
  <li>将0赋值给变量i;</li>
  <li>获取脚本的第一个参数给变量user;</li>
  <li>设置超时时间是300秒</li>
  <li>循环使用，不多说</li>
</ul>

<hr />

<p>在 expect脚本中, 最亮点的是 spawn 会启动一个进程，由 expect 和 send 组合负责跟该进程交互, in short </p>

<ul>
  <li>expect捕获进程需要什么信息</li>
  <li>send将这个信息发给进程</li>
  <li>expect eof与spawn对应，表示捕获终端输出信息的终止，即进程已结束</li>
  <li>expect都是使用 {}，且{, }使用时，前后需要留空格。 只要其中一项符合，就会执行该项，类似switch</li>
</ul>

<p>看完以下代码相信你就明白其魅力了 ：）</p>

<p>```sh
#!/usr/bin/expect</p>

<p>set timeout 10
set host [lindex $argv 0]
set username [lindex $argv 1]
set password [lindex $argv 2]</p>

<p>spawn ssh $username@$host
expect {
    “(yes/no)?” {
        send “yes\n”
        expect “<em>assword:” { send “$password\n” }
    }
    “</em>assword:” {
        send “$password\n”
    }
}</p>

<p>expect “$”
expect eof
```</p>

<p>使用时, 执行如下脚本命令.  其中<code>expect</code> 捕获到 “*assword:”, 发送 <code>$password</code> 变量,  捕获到<code>$</code>符号，表示登陆成功，结束 spawn 进程</p>

<p><code>
./autosh.exp xxx(ip地址) xxx(用户名) xxx(密码)
</code></p>

<hr />

<p>感觉这样的脚本在自动化运维可以有很多运用之处, 至少让你可以在执行需要交互命令的时候跑去喝茶。
Happy Hacking :-)</p>

]]></content>
  </entry>
  
</feed>
