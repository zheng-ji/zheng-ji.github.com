<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: System | 织网]]></title>
  <link href="http://zheng-ji.github.com/blog/categories/system/atom.xml" rel="self"/>
  <link href="http://zheng-ji.github.com/"/>
  <updated>2015-09-09T23:11:34+08:00</updated>
  <id>http://zheng-ji.github.com/</id>
  <author>
    <name><![CDATA[zheng-ji]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ansible 使用经验]]></title>
    <link href="http://zheng-ji.github.com/blog/2015/09/05/ansiblede-shi-yong-jing-yan/"/>
    <updated>2015-09-05T18:09:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2015/09/05/ansiblede-shi-yong-jing-yan</id>
    <content type="html"><![CDATA[<p>当你只有一两台服务器的情况下，可以直接登上服务器，手敲命令完成软件部署，代码发布等工作。但假如你有10台，100台的时候，这种方式不仅浪费大量时间，而且给人为犯错带来了可能。于是我们选择 Ansible 来做自动化批量操作。</p>

<p>之前有记录一些 Ansible 入门的使用,请看<a href="http://wiki.zheng-ji.info/Sys/ansible.html">这里</a>, 这半年的积累, 总结一些实用的经验, 记录了一把。</p>

<ul>
  <li><a href="#第一节">配置 ansible.cfg 文件</a></li>
  <li><a href="#第二节">使用 ansible role 来区分业务</a></li>
  <li><a href="#第三节">files 目录的路径定位</a></li>
  <li><a href="#第四节">使用 tags 区分不同操作</a></li>
  <li><a href="#第五节">规划 ansible roles 的 tasks 文件</a></li>
  <li><a href="#第六节">ansible-play-book 一些常用的选项</a></li>
</ul>

<h3 id="第一节">更好地配置文件</h3>

<p>我们会如下配置 /etc/ansible/host, 特意指明用户与 端口</p>

<p>```
[web-cluster]</p>
<node-1-ip> ansible_ssh_port=<your port=""> ansible_ssh_user=zj
<node-2-ip> ansible_ssh_port=<your port=""> ansible_ssh_user=zj
```

在 /etc/ansible/ansible.cfg 文件里
我们特意提及了 ansible-role 的配置，未来我们会使用这个东西

```
roles_path    = /home/zj/my-ansible/roles
```


<h3 id="第二节">使用 ansible role 来区分业务</h3>

打开 ansible 部署脚本的文件夹, 目录树如下


```
cd /home/zj/my-ansible/
haproxy
     - entry.yaml
roles
     - haproxy
        - files
        - handlers
        - vars
        - tasks
```

我用一个管理 haproxy 的例子来讲解这种方式。
在 roles 目录下创建 haproxy, 如上所示，需要有四个目录;

* files 目录下放置需要被传输到远端的文件;
* vars  目录下有一个 main.yml 文件,可以定义一些通用的配置变量，可以在 ansbile 脚本中使用;
* handlers 目录下有一个 main.yml, 可以定义一些通用的操作，比如重启服务等;
* tasks 目录下是我们编写 main.yml 脚本，执行业务逻辑的地方;

&gt; 那么 ansible role 的入口在哪呢？

在 ~/my-ansible/haproxy/entry.yml 中，指定了roles的角色，如此一来， 
ansible-playbook 就会去 /home/zj/my-ansible/roles/haproxy 准备执行 tasks/main.yml 

```
- hosts: web-cluster
  roles:
    - haproxy
```

<h3 id="第三节">files 目录的路径定位</h3>

摘取 ~/my-ansible/roles/haproxy/tasks/main.yml

```
- name: copy haproxy conf
  copy: src=haproxy.cfg dest=/etc/haproxy/haproxy.cfg owner=root group=root
  sudo: yes
```

这里的 src=haproxy.cfg 意味着 ~/my-ansible/roles/haproxy/files/haproxy.cfg

<h3 id="第四节">使用 tags 区分不同操作</h3>

```
- name: install ppa
  shell: add-apt-repository -y ppa:vbernat/haproxy-1.5
  sudo: yes
  tags:
    - install-haproxy
```

以下命令，是使用 tags 参数区分操作的例子

```
cd ~/my-ansible/haproxy
ansible-playbook entry.yml -v -K --tags "install-haproxy"
```

<h3 id="第五节">规划 ansible roles 的 tasks 目录</h3>

tasks 目录有一个主执行文件 main.yml, 因为业务操作步骤太多，导致 main.yml 文件很长，那么可读性就下降了。为此，我们使用了 include 语法。

cat ~/my-ansible/roles/haproxy/tasks/main.yml

```
- include: 'install-haproxy.yml'
```

include 上述文件，这样 main.yml 就显得简洁，我们可以将相关的操作写在对应的 yml 文件里

cat ~/my-ansible/roles/haproxy/tasks/install-haproxy.yml

```
- name: copy haproxy conf
  copy: src=haproxy.cfg dest=/etc/haproxy/haproxy.cfg owner=root group=root
  sudo: yes
  tags:
     - install-haproxy
```
tags 最好也与该 yml 文件名一致，清晰分明

<h3 id="第六节">ansible-play-book 一些常用的选项</h3>


* -K 需要 sudo 权限去客户机执行命令，会提示你输入密码
* -v 可以输出冗余的执行过程
* --check 可以测试脚本执行情况，但实际并未在远程机器执行
* --tags 提示 ansible-play-book 调用哪些 tags 命令

使用过ansible roles 之后，最大的体会是操作调理化，甚至编程化，合理的利用 handler, vars, 能更加优雅抽象。

----

上述的例子在 Github 有代码, 结合本文阅读可能更容易上手
[Link](https://github.com/zheng-ji/ToyCollection/tree/master/my-ansible) 


</your></node-2-ip></your></node-1-ip>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记录错误登陆的 btmp 文件]]></title>
    <link href="http://zheng-ji.github.com/blog/2015/07/24/ji-lu-cuo-wu-deng-lu-de-btmpwen-jian/"/>
    <updated>2015-07-24T23:06:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2015/07/24/ji-lu-cuo-wu-deng-lu-de-btmpwen-jian</id>
    <content type="html"><![CDATA[<p>今天查看了服务器时，发现 <code>/var/log/btmp</code> 日志文件较大。</p>

<p>此文件是记录错误登录的日志， 文件较大意味着有人使用密码字典登录ssh服务，
这个文件是需要用 <code>lastb</code> 命令才可读的。</p>

<p>查看尝试恶意登陆的前十个IP</p>

<p><code>
sudo lastb | awk '{ print $3}' | awk '{++S[$NF]} END {for(a in S) print a, S[a]}' | sort -rk2 |head
</code></p>

<p>如果有有必要封阻IP的话，可以执行：</p>

<p><code>
iptables -A INPUT -i eth0 -s *.*.*.0/24 -j DROP
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建 Postfix]]></title>
    <link href="http://zheng-ji.github.com/blog/2015/05/17/da-jian-postfix/"/>
    <updated>2015-05-17T00:25:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2015/05/17/da-jian-postfix</id>
    <content type="html"><![CDATA[<p>我们需要搭建邮件服务，采用Postfix服务, 坑点不少，遂记录。
现在我们决定在 <code>IP：1.2.3.4</code> 的机器上部署<code>Postfix</code>服务，让它可以发邮件</p>

<h3 id="section">安装</h3>

<p><code>
sudo apt-get install postfix
</code></p>

<h3 id="section-1">配置</h3>

<p>编辑 <code>/etc/postfix/main.cnf</code></p>

<p><code>
smtpd_banner = $myhostname ESMTP $mail_name (Ubuntu)
biff = no
append_dot_mydomain = no
readme_directory = no
smtpd_tls_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem
smtpd_tls_key_file=/etc/ssl/private/ssl-cert-snakeoil.key
smtpd_use_tls=yes
smtpd_tls_session_cache_database = btree:${data_directory}/smtpd_scache
smtp_tls_session_cache_database = btree:${data_directory}/smtp_scache
myhostname = mail.zheng-ji.info 邮箱服务器域名
alias_maps = hash:/etc/aliases
alias_database = hash:/etc/aliases
myorigin = $myhostname
mydestination = mail.zheng-ji.info, localhost.localdomain, localhost
mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128, hash:/etc/postfix/access 可以使用这个邮箱服务的外部地址
relay_domains = $mydestination
inet_interfaces = all
inet_protocols = all
</code></p>

<h3 id="section-2">授权</h3>

<p>为了让邮件能真正到达对方邮箱而不被视为垃圾邮件， 我们需要进行DNS权威认证</p>

<p><code>
A 记录指向 1.2.3.4
MX 记录也指向 1.2.3.4
TXT 记录 v=spf1 ip4:1.2.3.4 ~all
</code></p>

<p>以上操作是防止被认为垃圾邮件。</p>

<p>外部需要访问该Postfix 服务发送邮件，需要有access权限,
编辑/etc/postfix/access, 假设 <code>IP:5.6.7.8</code> 的机器想访问该服务</p>

<p><code>
5.6.7.8  OK
</code></p>

<p>重启并授权生效</p>

<p><code>
sudo service postfix restart
postmap access
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx 错误码]]></title>
    <link href="http://zheng-ji.github.com/blog/2014/12/13/nginxcuo-wu-ma/"/>
    <updated>2014-12-13T15:18:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2014/12/13/nginxcuo-wu-ma</id>
    <content type="html"><![CDATA[<p>在定位线上服务问题的时候，通常会去查看<code>Nginx</code> 的<code>error log</code></p>

<p>那么 error 的定义, 对查找问题就显得很有帮助</p>

<ul>
  <li>upstream prematurely closed connection</li>
</ul>

<blockquote>
  <p>请求uri的时候出现的异常，是由于 upstream 还未返回应答给用户时用户断掉连接造成的，对系统没有影响，可以忽略</p>
</blockquote>

<ul>
  <li>recv() failed (104: Connection reset by peer) </li>
</ul>

<blockquote>
  <p>服务器的并发连接数超过了其承载量，服务器会将其中一些连接Down掉；客户关掉了浏览器，而服务器还在给客户端发送数据;</p>
</blockquote>

<ul>
  <li>(111: Connection refused) while connecting to upstream </li>
</ul>

<blockquote>
  <p>用户在连接时，若遇到后端 upstream 挂掉或者不通，会收到该错误</p>
</blockquote>

<ul>
  <li>(111: Connection refused) while reading response header from upstream </li>
</ul>

<blockquote>
  <p>用户在连接成功后读取数据时，若遇到后端 upstream 挂掉或者不通，会收到该错误</p>
</blockquote>

<ul>
  <li>(111: Connection refused) while sending request to upstream </li>
</ul>

<blockquote>
  <p>Nginx 和 upstream 连接成功后发送数据时，若遇到后端 upstream 挂掉或者不通，会收到该错误</p>
</blockquote>

<ul>
  <li>(110: Connection timed out) while connecting to upstream </li>
</ul>

<blockquote>
  <p>nginx 连接后面的 upstream 时超时</p>
</blockquote>

<ul>
  <li>(110: Connection timed out) while reading upstream </li>
</ul>

<blockquote>
  <p>nginx 读取来自 upstream 的响应时超时 </p>
</blockquote>

<ul>
  <li>(110: Connection timed out) while reading response header from upstream </li>
</ul>

<blockquote>
  <p>nginx 读取来自 upstream 的响应头时超时</p>
</blockquote>

<ul>
  <li>(110: Connection timed out) while reading upstream </li>
</ul>

<blockquote>
  <p>nginx读取来自 upstream 的响应时超时</p>
</blockquote>

<ul>
  <li>(104: Connection reset by peer) while connecting to upstream </li>
</ul>

<blockquote>
  <p>upstream发送了 RST，将连接重置</p>
</blockquote>

<ul>
  <li>upstream sent invalid header while reading response header from upstream </li>
</ul>

<blockquote>
  <p>upstream 发送的响应头无效</p>
</blockquote>

<ul>
  <li>upstream sent no valid HTTP/1.0 header while reading response header from upstream</li>
</ul>

<blockquote>
  <p>upstream 发送的响应头无效</p>
</blockquote>

<ul>
  <li>client intended to send too large body </li>
</ul>

<blockquote>
  <p>用于设置允许接受的客户端请求内容的最大值，默认值是1M，client 发送的 body 超过了设置值</p>
</blockquote>

<ul>
  <li>reopening logs </li>
</ul>

<blockquote>
  <p>用户发送kill  -USR1命令</p>
</blockquote>

<ul>
  <li>gracefully shutting down</li>
</ul>

<blockquote>
  <p>用户发送kill  -WINCH命令</p>
</blockquote>

<ul>
  <li>no live upstreams while connecting to upstream </li>
</ul>

<blockquote>
  <p>upstream 下的 server 全都挂了</p>
</blockquote>

<ul>
  <li>SSL_do_handshake() failed</li>
</ul>

<blockquote>
  <p>SSL握手失败</p>
</blockquote>

<ul>
  <li>ngx_slab_alloc() failed: no memory in SSL session shared cache</li>
</ul>

<blockquote>
  <p>ssl_session_cache大小不够等原因造成</p>
</blockquote>

<ul>
  <li>could not add new SSL session to the session cache while SSL handshaking</li>
</ul>

<blockquote>
  <p>ssl_session_cache 大小不够等原因造成</p>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用到的Tcpdump]]></title>
    <link href="http://zheng-ji.github.com/blog/2014/11/29/yong-dao-de-tcpdump/"/>
    <updated>2014-11-29T14:15:00+08:00</updated>
    <id>http://zheng-ji.github.com/blog/2014/11/29/yong-dao-de-tcpdump</id>
    <content type="html"><![CDATA[<p>开发中，要定位具体问题，特别是网络问题的时候，多数是要晋出<code>tcpdump</code>，遗憾的是我略懂皮毛，有必要深入一些。
简单说下我常用的 TcpDump的方法</p>

<p><code>
tcpdump -i eth0 -Xxn port 80 -s 0 -c 1024 
</code></p>

<p>如果仅仅是看manual  多数时候还是会忘记，好记性不如烂笔头，上述的选项是我认为很有用的</p>

<p><code>
-i 指定网卡
-Xxn X使用Ascii和16进制，n 表示 ip 用数字表示
-s 0 表示整包抓取
-c 1024 表示包得大小
</code></p>

<p>如果希望将抓包过程中保留下来，可以在上述命令尾部加上 <code>-w trace.cap</code>
这种格式的文件，文本编辑器是无法理解，需要特殊的软件才能回复，比如 <code>wireshark</code></p>

<p>Tcpdump 中的 flag 有必要提下：</p>

<ul>
  <li>PSH 代表要求发送立即发送缓冲区内的其他对应数据包，无需缓冲区满才发送</li>
  <li>RST 如果RST=1表示连接马上结束，无需等待终止确认手续，发送端已经断线</li>
  <li>SYNC 表示主动连接到对方，建立连接</li>
  <li>FIN 表示传送结束，发送方等待对方响应</li>
</ul>

<p>通过 wireshark 可以再现所谓的三次握手和四次挥手过程。</p>
]]></content>
  </entry>
  
</feed>
