
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>织网</title>
  <meta name="author" content="zheng-ji">

  
  <meta name="description" content="服务器上每个PHP进程占用一个数据库链接，当有 n 台服务器, 每台服务器用用100 * m 个PHP 进程的时候，数据库的压力是有点小大。 为了解决这个问题, 可以有的选择是： 业内炒的比较火的有，奇虎Atlas, 淘宝前架构师写的OneProxy, 官方的MySQL-Proxy; &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zheng-ji.github.com/blog/page/2">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="织网" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.useso.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">-->
<!--<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">织网</a></h1>
  
    <h2>身体和灵魂，总有一个在路上</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:zheng-ji.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
  <li><a href="http://wiki.zheng-ji.info">Wiki</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/02/03/haproxy-plus-mysql/">Haproxy - MySQl 的负载均衡</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-02-03T23:17:00+08:00" pubdate data-updated="true">Feb 3<span>rd</span>, 2015</time>
        
        
          | <a href="/blog/2015/02/03/haproxy-plus-mysql/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>服务器上每个PHP进程占用一个数据库链接，当有 n 台服务器, 每台服务器用用100 * m 个PHP 进程的时候，数据库的压力是有点小大。</p>

<p>为了解决这个问题, 可以有的选择是：</p>

<ul>
  <li>业内炒的比较火的有，奇虎<a href="https://github.com/Qihoo360/Atlas">Atlas</a>, 淘宝前架构师写的<a href="http://weibo.com/dbatools">OneProxy</a>, 官方的MySQL-Proxy;</li>
  <li>从连接层解决负载均衡的压力，Haproxy 所擅长的事情</li>
</ul>

<p>对于第一个选择，同事做过调研，使用起来不太放心。官方库就无人维护, 于是，最后选择了 Haproxy 来承担数据库的前端代理.链接数下降明显。</p>

<hr />

<h3 id="section">一些关键的配置</h3>

<p>参考<a href="http://www.sysads.co.uk/2014/08/install-haproxy-1-5-6-on-ubuntu-14-04/">连接</a>:</p>

<p>以下是配置内容</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">listen mysql-cluster
</span><span class="line">    bind 127.0.0.1:3306  # 连接本地3306 到后端的DB
</span><span class="line">    mode tcp
</span><span class="line">    option mysql-check user haproxy_check # haproxy_check 是该haproxy用户
</span><span class="line">    balance roundrobin
</span><span class="line">    server mysql-1 10.0.0.1:3306 check # 后端DB
</span><span class="line">    server mysql-2 10.0.0.2:3306 check # 后端DB
</span><span class="line">
</span><span class="line">listen 0.0.0.0:8080 # 监控页面
</span><span class="line">    mode http
</span><span class="line">    stats enable
</span><span class="line">    stats uri /
</span><span class="line">    stats realm Strictly\ Private
</span><span class="line">    stats auth A_Username:YourPassword
</span><span class="line">    stats auth Another_User:passwd</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>值得注意的是，我们需要在DB 里面添加用户 haproxy_check,使得它有权限访问这个数据库。一开始我习惯用</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">假设我的内网ip是 192.168.1.5
</span><span class="line">create user 'haproxy_check'@'192.168.1.5' identified by 'xxx';
</span><span class="line">flush privileges;</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>事实上这样连接 haproxy 会报：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">mysql -h127.0.0.1 -uusername -p
</span><span class="line">lost connection to mysql server at 'reading initial communication packet'</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>后来老实按照 digitalocean 的文章修改成</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">INSERT INTO mysql.user (Host,User) values ('192.168.1.5','haproxy_check');
</span><span class="line">flush privileges;</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>测试就通过了.好奇怪，在我的理解中很不应该, 明天继续看看为什么会这么奇怪。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/31/da-jian-elasticsearchyu-kibana/">搭建elasticsearch与kibana</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-31T12:52:00+08:00" pubdate data-updated="true">Jan 31<span>st</span>, 2015</time>
        
        
          | <a href="/blog/2015/01/31/da-jian-elasticsearchyu-kibana/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>ElasticSearch是一个基于Lucene构建的开源，分布式，RESTful搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速,
Kibana 是一个与之配套的 web 界面。</p>

<h3 id="section">安装所需的：</h3>

<ul>
  <li>需要openJDK</li>
  <li>下载并安装 <a href="http://www.elasticsearch.org/overview/elkdownloads/">elasticsearch-1.4.2.deb</a></li>
  <li>下载并安装 <a href="http://www.elasticsearch.org/overview/elkdownloads/">kibana-4.0.0-beta3.tar.gz</a></li>
</ul>

<h3 id="section-1">配置相关</h3>
<p>启动 elasticsearch 方式如下</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo service elasticsearch restart</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>我是使用 <a href="http://wiki.zheng-ji.info/Sys/supervisor.html">supervisor</a> 启动 kibana, </li>
  <li>同时使用 <a href="http://wiki.zheng-ji.info/Sys/monit.html">monit</a> 监控elasticsearch </li>
</ul>

<p>在/etc/defaut/elasticsearch 配置数据文件目录的地址，log 地址，调整内存和堆栈大小，个人认为机器配置的50% 就可以了。</p>

<p>Nginx 配置，使得kibanan可以被外部访问，eleasticsearch 默认监听的是5601：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">server {
</span><span class="line">        listen 80;
</span><span class="line">        #auth_basic_user_file /home/ymserver/auth/kibana-user;
</span><span class="line">        error_log /home/ymserver/log/nginx/kibana.err.log;
</span><span class="line">        location / {
</span><span class="line">            proxy_pass http://127.0.0.1:5601$request_uri;
</span><span class="line">            proxy_set_header Host $http_host;
</span><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 
</span><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;
</span><span class="line">        }
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-2">使用过程</h3>
<p>Python 有支持elasticsearch 的库 <a href="https://github.com/elasticsearch/elasticsearch-py">elasticsearch-py</a>，
用其导数据进入elasticsearch,需要指定好索引。</p>

<p>使用restful<a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/">查询</a>， 
如下例子：其中’2014-12-18’是索引名，q后面是查询条件，_all表示全部索引</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class=""><span class="line">curl -XGET 'http://localhost:9200/2014-12-18/_search/?q=name:861160022835011'
</span><span class="line">curl -XGET 'http://localhost:9200/_all/_search/?q=name:861160022835011'
</span><span class="line">curl -XGET localhost:9200/_search -d '
</span><span class="line">{
</span><span class="line">    "query": {
</span><span class="line">        "bool": {
</span><span class="line">            "must": [
</span><span class="line">            {
</span><span class="line">                "term": {
</span><span class="line">                    "field1": "X"
</span><span class="line">                }
</span><span class="line">            },
</span><span class="line">            {
</span><span class="line">                "term": {
</span><span class="line">                    "field3": "Z"
</span><span class="line">                }
</span><span class="line">            }
</span><span class="line">            ],
</span><span class="line">            "must_not": {
</span><span class="line">                "term": {
</span><span class="line">                    "field2": "Y"
</span><span class="line">                }
</span><span class="line">            }
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">}'</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-3">性能概述</h3>
<p>导入1个月的日志4.2G，31天的文件，每天一个索引，用了6个小时，elasticsearch用了 6.7G 的空间，在海量数据查询1s内响应。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/01/21/percona-toolkitxiao-xiang-li-di-pt-archiver/">Percona 小箱里的pt-archiver</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-01-21T23:27:00+08:00" pubdate data-updated="true">Jan 21<span>st</span>, 2015</time>
        
        
          | <a href="/blog/2015/01/21/percona-toolkitxiao-xiang-li-di-pt-archiver/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在管理线上数据库，时常要做一些数据归档操作，在没有了解 <code>Percona toolkit</code> 之前，第一个想到的是在夜深人静的时候使用 <code>MySqlDump</code> 来完成这件事情。但它不是我们的优质选择，理由有：</p>

<ul>
  <li><code>MySqlDump</code> 只能备份在本机，不能直接做远端备份</li>
  <li>导出数据量太大的时候会锁表, 即使它的速度很快，但是在线上服务这是很危险的操作</li>
  <li>它仅仅只能导出，无法做到同时删除(可能不是太有必要)</li>
</ul>

<p>面对上述的场景，<code>Percona Toolkit</code> 让DBA 有了更好地选择，<a href="http://www.percona.com/doc/percona-toolkit/2.1/pt-archiver.html">pt-archiver</a> 应时而生。</p>

<h2 id="pt-archiver-">pt-archiver 介绍：</h2>

<p>根据官方文档的说法，几乎不会对线上的OTLP操作有影响：</p>

<blockquote>
  <p>The goal is a low-impact, forward-only job to nibble old data out of the table without impacting OLTP queries much</p>
</blockquote>

<p>它可以帮助我们将数据归档到文件, 另一个数据库，或者同一个数据库的另一个表, 亦或是用于合并两个表的内容。</p>

<h2 id="section">用法介绍：</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">pt-archiver [OPTION...] --source DSN --where WHERE</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>归档的文件方便使用 load data infile 命令导入数据。另外你还可以用它来执行 delete 操作。这个工具默认的会删除源中的数据，使用的时候请注意。</p>

<p>假如我们将数据库里符合条件的记录归档到文件，并不做删除操作。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">pt-archiver --ask-pass --progress 100000 --no-delete --no-check-charset --source h=localhost,u=root,D=blog,t=comment--file /home/ubuntu/tmp/comment--where 'time &lt; "2013-12-31h"'</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>注意的选项参数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">--ask-pass        提示要求输密码
</span><span class="line">--progress num    执行num行在界面通知我们
</span><span class="line">--source h,D,t    数据源
</span><span class="line">--no-delete       加上这个参数并不会执行删除操作
</span><span class="line">--dry-run         仅仅将执行语句打印在终端，事实上并不执行。可以用于检测执行过程
</span><span class="line">--where           执行语句，需要用冒号包围起来
</span><span class="line">--limit           批量操作的数量，合理提高这个数值可以加快archive速度</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-1">小总结</h3>

<p>通过开启 mysql 的 <code>general log</code>, 可以发现pt-archiver 执行时，是分批commit 的事务，因此执行效率会慢，在8核16G 内存的生产环境机器备份 1kw 条记录, 耗时150 分钟。 但基本不对服务造成影响，而且可以不用深夜进行, 值得一用。</p>

<p>最近攒了好多好工具和经验，要好好整理搬上来和大家分享才是。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/13/nginxcuo-wu-ma/">Nginx错误码</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-13T15:18:00+08:00" pubdate data-updated="true">Dec 13<span>th</span>, 2014</time>
        
        
          | <a href="/blog/2014/12/13/nginxcuo-wu-ma/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在定位线上服务问题的时候，通常会去查看<code>Nginx</code> 的<code>error log</code></p>

<p>那么 error 的定义, 对查找问题就显得很有帮助</p>

<ul>
  <li>upstream prematurely closed connection</li>
</ul>

<blockquote>
  <p>请求uri的时候出现的异常，是由于 upstream 还未返回应答给用户时用户断掉连接造成的，对系统没有影响，可以忽略</p>
</blockquote>

<ul>
  <li>recv() failed (104: Connection reset by peer) </li>
</ul>

<blockquote>
  <p>服务器的并发连接数超过了其承载量，服务器会将其中一些连接Down掉；客户关掉了浏览器，而服务器还在给客户端发送数据;</p>
</blockquote>

<ul>
  <li>(111: Connection refused) while connecting to upstream </li>
</ul>

<blockquote>
  <p>用户在连接时，若遇到后端 upstream 挂掉或者不通，会收到该错误</p>
</blockquote>

<ul>
  <li>(111: Connection refused) while reading response header from upstream </li>
</ul>

<blockquote>
  <p>用户在连接成功后读取数据时，若遇到后端 upstream 挂掉或者不通，会收到该错误</p>
</blockquote>

<ul>
  <li>(111: Connection refused) while sending request to upstream </li>
</ul>

<blockquote>
  <p>Nginx 和 upstream 连接成功后发送数据时，若遇到后端 upstream 挂掉或者不通，会收到该错误</p>
</blockquote>

<ul>
  <li>(110: Connection timed out) while connecting to upstream </li>
</ul>

<blockquote>
  <p>nginx 连接后面的 upstream 时超时</p>
</blockquote>

<ul>
  <li>(110: Connection timed out) while reading upstream </li>
</ul>

<blockquote>
  <p>nginx 读取来自 upstream 的响应时超时 </p>
</blockquote>

<ul>
  <li>(110: Connection timed out) while reading response header from upstream </li>
</ul>

<blockquote>
  <p>nginx 读取来自 upstream 的响应头时超时</p>
</blockquote>

<ul>
  <li>(110: Connection timed out) while reading upstream </li>
</ul>

<blockquote>
  <p>nginx读取来自 upstream 的响应时超时</p>
</blockquote>

<ul>
  <li>(104: Connection reset by peer) while connecting to upstream </li>
</ul>

<blockquote>
  <p>upstream发送了 RST，将连接重置</p>
</blockquote>

<ul>
  <li>upstream sent invalid header while reading response header from upstream </li>
</ul>

<blockquote>
  <p>upstream 发送的响应头无效</p>
</blockquote>

<ul>
  <li>upstream sent no valid HTTP/1.0 header while reading response header from upstream</li>
</ul>

<blockquote>
  <p>upstream 发送的响应头无效</p>
</blockquote>

<ul>
  <li>client intended to send too large body </li>
</ul>

<blockquote>
  <p>用于设置允许接受的客户端请求内容的最大值，默认值是1M，client 发送的 body 超过了设置值</p>
</blockquote>

<ul>
  <li>reopening logs </li>
</ul>

<blockquote>
  <p>用户发送kill  -USR1命令</p>
</blockquote>

<ul>
  <li>gracefully shutting down</li>
</ul>

<blockquote>
  <p>用户发送kill  -WINCH命令</p>
</blockquote>

<ul>
  <li>no live upstreams while connecting to upstream </li>
</ul>

<blockquote>
  <p>upstream 下的 server 全都挂了</p>
</blockquote>

<ul>
  <li>SSL_do_handshake() failed</li>
</ul>

<blockquote>
  <p>SSL握手失败</p>
</blockquote>

<ul>
  <li>ngx_slab_alloc() failed: no memory in SSL session shared cache</li>
</ul>

<blockquote>
  <p>ssl_session_cache大小不够等原因造成</p>
</blockquote>

<ul>
  <li>could not add new SSL session to the session cache while SSL handshaking</li>
</ul>

<blockquote>
  <p>ssl_session_cache 大小不够等原因造成</p>
</blockquote>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/29/yong-dao-de-tcpdump/">用到的Tcpdump</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-29T14:15:00+08:00" pubdate data-updated="true">Nov 29<span>th</span>, 2014</time>
        
        
          | <a href="/blog/2014/11/29/yong-dao-de-tcpdump/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>开发中，要定位具体问题，特别是网络问题的时候，多数是要晋出<code>tcpdump</code>，遗憾的是我略懂皮毛，有必要深入一些。
简单说下我常用的 TcpDump的方法</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">tcpdump -i eth0 -Xxn port 80 -s 0 -c 1024 </span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果仅仅是看manual  多数时候还是会忘记，好记性不如烂笔头，上述的选项是我认为很有用的</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">-i 指定网卡
</span><span class="line">-Xxn X使用Ascii和16进制，n 表示 ip 用数字表示
</span><span class="line">-s 0 表示整包抓取
</span><span class="line">-c 1024 表示包得大小</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果希望将抓包过程中保留下来，可以在上述命令尾部加上 <code>-w trace.cap</code>
这种格式的文件，文本编辑器是无法理解，需要特殊的软件才能回复，比如 <code>wireshark</code></p>

<p>Tcpdump 中的 flag 有必要提下：</p>

<ul>
  <li>PSH 代表要求发送立即发送缓冲区内的其他对应数据包，无需缓冲区满才发送</li>
  <li>RST 如果RST=1表示连接马上结束，无需等待终止确认手续，发送端已经断线</li>
  <li>SYNC 表示主动连接到对方，建立连接</li>
  <li>FIN 表示传送结束，发送方等待对方响应</li>
</ul>

<p>通过 wireshark 可以再现所谓的三次握手和四次挥手过程。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/25/tired/">慢</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-25T22:20:00+08:00" pubdate data-updated="true">Nov 25<span>th</span>, 2014</time>
        
        
          | <a href="/blog/2014/11/25/tired/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这三个月以来,有30天是凌晨才离开公司的.甚至有好几天都通宵没有睡过,累。</p>

<p>貌似熟悉了凌晨的路灯,和冷冽的寒风。</p>

<p>技术的东西,整理在 EvertNote 里，但想写一些非技术的冲动似乎更强。</p>

<p>生活有很长的路要走, 几乎每天都在发现不足之处,只能让内心更强大, 去接受,去改变, 淡定去拥抱无时不刻的变化, 怀着信念与希望继续走着。</p>

<p>感谢 Everet 一直以来给我的信念, 我们也都在《感谢你让我上场》获得共鸣。我也坚信这位青年会是我们这届的骄傲。</p>

<p>我想让生活慢下来，做一些重要不紧急的事。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/02/nginxyu-phpxi-tong-can-shu-pei-zhi/">Nginx与php-fpm系统参数配置</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-02T15:46:00+08:00" pubdate data-updated="true">Nov 2<span>nd</span>, 2014</time>
        
        
          | <a href="/blog/2014/11/02/nginxyu-phpxi-tong-can-shu-pei-zhi/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>需要为机器调配参数了, 早些时候看过不少文章, 但没经历过始终不深刻, 以下讲的是在 8core 8G，Centos 配置 php-fpm 与 NGINX。</p>

<h3 id="php-fpm-">php-fpm 参数配置</h3>

<p>关于 php-fpm 的配置,Ubuntu系统中 <code>/etc/php5/fpm/pool.d</code>目录下, Centos是<code>/etc/php-fpm.d</code>目录下编辑<code>www.conf</code></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">listen = /var/run/php5-fpm.sock
</span><span class="line">listen.backlog = -1 (on FreeBSD -1 unlimit)
</span><span class="line">pm = static # 使用静态进程管理
</span><span class="line">pm.max_children = 128
</span><span class="line">request_terminate_timeout = 8s #设置太大，会导致work进程过多，来不及kill掉</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>编辑 <code>/etc/default/php5-fpm</code></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">ulimit -n 655360</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="nginx-">Nginx 配合参数</h3>

<ul>
  <li>启用irqbalance</li>
</ul>

<p>由于精简系统的服务没有开启irqbalance，irqbalance现在被证实为非常有必要的服务，他的主要功能是可以合理的调配使用各个 CPU 核心，特别是对于目前主流多核心的 CPU，简单的说就是能够把压力均匀的分配到各个 CPU 核心上，对提升性能有很大的帮助。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">shell&gt; yum -y install irqbalance
</span><span class="line">shell&gt; service irqbalance start
</span><span class="line">cat /proc/irqbalance #查看中断的分布</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>为nginx 绑定 cpu</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">worker_rlimit_nofile 300000;
</span><span class="line">worker_processes  8;
</span><span class="line">worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>连接数调整，</li>
</ul>

<p>nginx发起的连接数，远远超过了 php-fpm 所能处理的数目，导致端口（或socket）频繁被锁，造成堵塞。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class=""><span class="line">vi /etc/sysctl.conf 进行了微调
</span><span class="line">fs.file-max = 6553600
</span><span class="line">
</span><span class="line">vim /etc/security/limits.conf
</span><span class="line">* soft nofile 655360
</span><span class="line">* hard nofile 655360
</span><span class="line">
</span><span class="line">vim /etc/nginx/nginx.conf
</span><span class="line">
</span><span class="line">worker_rlimit_nofile 300000;
</span><span class="line">events {
</span><span class="line">    worker_connections 300000;
</span><span class="line">    use epoll;
</span><span class="line">}
</span><span class="line">http {
</span><span class="line">    keepalive_timeout  0; #关闭keepalive_timeout, 快速释放系统资源
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>从查到的资料看起来 8 核 理論值的最大連線數 = <code>worker_processes * worker_connections / 8</code></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/29/iptablezuo-natzhuan-fa/">iptable做NAT转发</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-29T22:38:00+08:00" pubdate data-updated="true">Oct 29<span>th</span>, 2014</time>
        
        
          | <a href="/blog/2014/10/29/iptablezuo-natzhuan-fa/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>简单简述下我遇到的问题:</p>

<p>现在局域网有2台机器, 其中一台机器(下文我们称之为ServerA)可以访问外网,有独立IP,而另外一台机器(ServerB)访问不了外网, 需要想办法让 ServerB 也能上网。</p>

<ul>
  <li>ServerA 操作</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">vi /etc/sysctl.conf
</span><span class="line">net.ipv4.ip_forward = 1
</span><span class="line">iptables -t nat -A POSTROUTING -s 10.4.0.0/16 -j MASQUERADE</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>ServerB</p>

<p>编辑 /etc/network/interface
主要是修改gateway 参数，指向 ServerA 的 IP</p>

<p><code>
sudo ifdown eth0; sudo ifup eth0</code> 
ServerB 就可以连接外网了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/23/mysql-unique-index/">唯一索引引发的思考</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-23T23:18:00+08:00" pubdate data-updated="true">Oct 23<span>rd</span>, 2014</time>
        
        
          | <a href="/blog/2014/10/23/mysql-unique-index/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近需要改动线上一个有千万条记录的表，涉及到加字段操作，这个表有索引，按照经验，为了加速修改表结构,去掉索引。由于我删除的是Unique Index, 而服务一直在写,程序依赖数据库的唯一索引去重,导致瞬间有重复数据,唯一索引重新加上时会报 <code>Duplicated Key entry Error</code>,</p>

<h3 id="section">回放事件</h3>

<p>我们的数据表，之前是有 <code>UNIQUE INDEX(cuid, aid)</code>, 因为去掉索引，服务持续写入，导致有重复记录，所幸的是，这是一个统计表, 不影响功能，所以需要找出重复的记录</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">select cuid,aid from (
</span><span class="line">    select cuid, aid,count(1) as num
</span><span class="line">    from register_chn 
</span><span class="line">    group by cuid,aid having num &gt; 1
</span><span class="line">) t;</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>显示有8条记录,如果手动删除,是很慢且愚蠢的做法,还是用 SQL 执行,镇定之后执行</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">delete from register_chn where (cuid,aid) in (
</span><span class="line">    select cuid,aid from (
</span><span class="line">        select cuid, aid,count(1) as num
</span><span class="line">        from register_chn
</span><span class="line">        group by cuid,aid having num &gt; 1
</span><span class="line">    ) t
</span><span class="line">);</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>影响了８条记录.然后瞬间加上索引.所幸是成功了, 事实上当时的合理操作应该是用事务。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class=""><span class="line">BEGIN;
</span><span class="line">delete from register_chn where (cuid,aid) in (
</span><span class="line">    select cuid,aid from (
</span><span class="line">        select cuid, aid,count(1) as num
</span><span class="line">        from register_chn
</span><span class="line">        group by cuid,aid having num &gt; 1
</span><span class="line">    ) t
</span><span class="line">);
</span><span class="line">alter table register_chn add unique index(cuid, aid);
</span><span class="line">COMMINT;</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-1">引发的思考</h3>

<p>后来想想, 上述方法虽然解决问题了, 但是有点碰运气成分。如果频繁快速地产生重复记录,也许就没那么好运了,事实上可以执行以下 SQL:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">alter ignore table register_chn add unique index(cuid, aid)；</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果你以为很简单,那就错了。这个方法在 MySQL 5.0 上使用是没问题的，但是在5.6 之前是有bug的，亲自测试Percona 版本5.5, 的确会失败
官方的解决方法是：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">set session old_alter_table = on;
</span><span class="line">alter ignore table register_chn add unique index(cuid, aid);</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在有主备的情况,记得执行前设置一下</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">set session sql_log_bin=off. </span></code></pre></td></tr></table></div></figure></notextile></div>
<p>以免备库报错。同样还需要在备库重复一下主库的操作, 这也算是一个不太完美的解决思路。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/21/mysqlde-na-xie-dong-tai-bian-liang/">Mysql的一些配置</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-21T23:18:00+08:00" pubdate data-updated="true">Oct 21<span>st</span>, 2014</time>
        
        
          | <a href="/blog/2014/10/21/mysqlde-na-xie-dong-tai-bian-liang/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>我想写一篇长期更新的文章，随着知识积累持续更新的文章，而最近遇到的在涉及的Mysql优化，便是一个可以琢磨的点，变量比较多，并且需要在每次采坑才来的深刻。</p>

<ul>
  <li>tmp_table_size
这个是临时表的大小，与之对应的有 <code>max_heap_size</code> 单位是Byte, <code>tmp_table_size</code> 的大小关乎临时表的大小, 如果设置太小，会导致一些数据直接写入磁盘，比较蛋疼, 看了官方文档，涉及到<code>Dynamic Variable=Yes</code>
那么这种配置便可以直接在终端用语句设置，并生效，不需要重启机器</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">set global tmp_table_size = 512 * 1024 *1024 </span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>max_connections
当<code>show processlist</code> 发现有好多链接的时候，客户端想登陆mysql却失败。可以执行, 看看是不是现有的链接数已经逼近</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">show global variable like '%max%'
</span><span class="line">set global max_connections 1000</span></code></pre></td></tr></table></div></figure></notextile></div>
<ul>
  <li>thread_concurrency</li>
</ul>

<p>同一时间与性的线程设置，如果分配不当，会导致<code>mysql</code>不能充分使用多｀cpu｀, 出现同一时刻只有一个核在工作。
<code>thread_concurrency</code> 应设为<code>CPU</code> 核数的2倍. 比如有一个双核的CPU, 那么<code>thread_concurrency</code>的应该为4; 2个双核的cpu, <code>thread_concurrency</code>的值应为8.</p>

<ul>
  <li>max_allowed_packet
如果需要进行mysqldump这类操作，需要调大</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">set global max_allowed_packet = 2*1024*1024*10</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>skip_slave_start
配置文件中建议加上skip-slave-start，以免在不需要时候slave线程自己开始执行了</li>
</ul>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/3/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Categories</h1>
<ul id="categories">
    <li><a href='/blog/categories/database'>DataBase</a></li><li><a href='/blog/categories/life'>Life</a></li><li><a href='/blog/categories/network'>NetWork</a></li><li><a href='/blog/categories/nginx'>Nginx</a></li><li><a href='/blog/categories/product'>Product</a></li><li><a href='/blog/categories/programe'>Programe</a></li><li><a href='/blog/categories/server'>Server</a></li><li><a href='/blog/categories/system'>System</a></li>
</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/08/16/twemproxy/">twemproxy 一个redis代理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/10/hackthon/">黑客马拉松</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/24/ji-lu-cuo-wu-deng-lu-de-btmpwen-jian/">记录错误登陆的btmp文件</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/12/my-dot-cnfpei-zhi-yi-ju/">my.cnf配置依据</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/11/qing-qiao-shi-shi-tong-ji-yong-hu-shu/">轻巧实时统计用户数</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/05/17/da-jian-postfix/">搭建Postfix</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/05/10/mysql-slave-relay-log-corrupt-chu-li-he-hui-fu/">MySQL Slave Relay log Corrupt 恢复</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/04/05/yong-bao-docker/">为服务端程序构建docker</a>
      </li>
    
  </ul>
</section>
<section>
<h1>友情链接</h1>
<ul>
    <span>
        <a href="http://everet.org/">EverET</a>
    </span>
    <span>
        <a href="http://www.kidsang.com/">Kid&#8217;s Zone</a>
    </span>
    <span>
        <a href="http://blog.onlyice.net">onlyice</a>
    </span>
</ul>
</section>

<section>
<h1>最近评论</h1>
<ul class="ds-recent-comments" data-num-items="10">
</ul>
<!--多说js加载开始，一个页面只需要加载一次 -->
<script type="text/javascript">
    var duoshuoQuery = {short_name:"zhengji"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';
        ds.async = true;ds.src = 'http://static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>
<!--多说js加载结束，一个页面只需要加载一次 -->
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - zheng-ji -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000421282'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/z_stat.php%3Fid%3D1000421282' type='text/javascript'%3E%3C/script%3E"));
  </script>
</p>

</footer>
  











</body>
</html>
