
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>织网</title>
  <meta name="author" content="zheng-ji">

  
  <meta name="description" content="Tengine 能动态加载第三方模块，成为我们青睐的选择，我们可以编译动态链接文件，而不需要重新安装 Nginx, 这对在线增强 webservice 很有帮助. 感谢 agentzh, lua-nginx-module, 可以让我们使用 lua 增强nginx的功能, 不言而喻，我们必须现有 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zheng-ji.github.com/blog/page/2">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="织网" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.useso.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">-->
<!--<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">织网</a></h1>
  
    <h2>身体和灵魂，总有一个在路上</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:zheng-ji.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
  <li><a href="http://wiki.zheng-ji.info">Wiki</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/10/29/gei-tengine-jia-shang-lua-tuo-zhan/">给 Tengine 加上 Lua 拓展</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-29T22:45:00+08:00" pubdate data-updated="true">Oct 29<span>th</span>, 2015</time>
        
        
          | <a href="/blog/2015/10/29/gei-tengine-jia-shang-lua-tuo-zhan/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Tengine 能动态加载第三方模块，成为我们青睐的选择，我们可以编译动态链接文件，而不需要重新安装 Nginx, 这对在线增强 webservice 很有帮助. 
感谢 agentzh, <a href="https://github.com/openresty/lua-nginx-module">lua-nginx-module</a>, 可以让我们使用 lua 增强nginx的功能, 不言而喻，我们必须现有 Lua 的环境，才能运行 ngx_lua;</p>

<h2 id="nginxlua">编译 nginx_lua</h2>

<p>官方推荐使用LuaJit,虽然也可以使用Lua，但是即时编译(Just-In-Time Compiler)混合了动态编译和静态编译，一句一句编译源代码，但是会将翻译过的代码缓存起来以降低性能损耗。</p>

<ul>
  <li>下载安装</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">wget http://luajit.org/download/LuaJIT-2.0.4.tar.gz
</span><span class="line">tar zxvf LuaJIT-2.0.4.tar.gz
</span><span class="line">cd LuaJIT-2.0.4
</span><span class="line">make
</span><span class="line">make install</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>设置环境变量</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">export LUAJIT_LIB=/usr/local/lib
</span><span class="line">export LUAJIT_INC=/usr/local/include/luajit-2.0</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>然后编译ngx-lua-module.so</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/usr/local/share/dso_tool/ --path=/Path/To/Lua-Nginx-module</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>设置动态库</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">&gt; echo "/usr/local/lib" &gt; /etc/ld.so.conf.d/usr_local_lib.conf
</span><span class="line">&gt; ldconfig</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="tengine-">在 Tengine 中启用</h3>

<p><code>nginx.conf</code> 中先加载动态库</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">dso {
</span><span class="line">    load ngx_load_module;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在 nginx.conf 中添加</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">lua_code_cache on/off;</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>来开启是否将代码缓存，所以每次变更 “*.lua” 文件时，必须重启 nginx 才可生效.</p>

<h3 id="ngxluawaf">使用 ngx_lua_waf</h3>

<p>有了基础环境，我们要开始发挥 ngx lua 的优点了, 我用他安装了 waf (web application firework)
<a href="https://github.com/loveshell/ngx_lua_waf">ngx_lua_waf</a>，这是一个通过 ngx_lua 编写的 web 应用防火墙, 在使用过程中也发现了 ngx_lua_waf 一个bug，给他提了一个<a href="https://github.com/loveshell/ngx_lua_waf/pull/70">Pull Request</a>, 码农生涯第一个 PR.</p>

<hr />

<p>注：
静态编译的程序在执行前全部被翻译为机器码，而动态直译执行的则是一句一句边运行边翻译。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/10/06/ji-lu-shi-yong-flaskde-dian-di/">记录使用 Flask 的点滴</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-06T13:21:00+08:00" pubdate data-updated="true">Oct 6<span>th</span>, 2015</time>
        
        
          | <a href="/blog/2015/10/06/ji-lu-shi-yong-flaskde-dian-di/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>喜欢 Flask 经典的 RestFul 设计风格，以及它与 Gevent 的优雅结合，可以帮助我们轻松构建异步非阻塞应用，烂笔头记下一些较好的实践。</p>

<ul>
  <li><a href="#第一节">消息反馈</a></li>
  <li><a href="#第二节">Flask 上下文</a></li>
  <li><a href="#第三节">注册 JinJia 模板过滤器</a></li>
  <li><a href="#第四节">itsdangerous 生成过期时间 Json 签名</a></li>
  <li><a href="#第五节">一种较好的项目组织方式</a></li>
  <li><a href="#第六节">BluePrint 的好</a></li>
  <li><a href="#第七节">Json 返回</a></li>
  <li><a href="#第八节">自定义出错页面</a></li>
  <li><a href="#第九节">WTF 跨站脚本防御</a></li>
</ul>

<h3 id="第一节">消息反馈</h3>

<p>Flask 提供了一个非常简单的方法来使用闪现系统向用户反馈信息。
闪现系统使得在一个请求结束的时候记录一个信息，然后在且仅仅在下一个请求中访问这个数据。这通常配合一个布局模板实现</p>

<p><a href="http://docs.jinkan.org/docs/flask/patterns/flashing.html">文档链接</a></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line"># 视图函数需要调用
</span><span class="line">flash('your response message for user')
</span><span class="line">
</span><span class="line"># 前端页面调用
</span><span class="line">for message in get_flashed_messages()
</span><span class="line">就可以输出反馈信息</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="第二节">Flask 上下文</h3>

<p>有两种上下文：程序上下文，请求上下文</p>

<ul>
  <li>current_app： 程序级别上下文，当前激活程序的实例。</li>
  <li>g: 请求级别的上下文</li>
  <li>request: 是请求级别的上下文，封装了客户端发出的 Http 请求中的内容</li>
  <li>session: 用户会话，用于存储请求之间需要记住的键值对</li>
</ul>

<h3 id="第三节">注册 JinJia 模板过滤</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">def reverse_filter(s):
</span><span class="line">    return s[::-1]
</span><span class="line">
</span><span class="line">app.jinja_env.filters['reverse'] = reverse_filter</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="第四节">itsdangerous 生成过期时间 Json 签名</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class=""><span class="line">serialaizer = Serializer(SECRET_KEY, expires_in=EXPIRES)
</span><span class="line">info = {'id':'xxx'}
</span><span class="line">session = serialaizer.dumps(info)
</span><span class="line">
</span><span class="line"># 判断 session 时间
</span><span class="line">info = None
</span><span class="line">try:
</span><span class="line">    info = serialaizer.loads(session)
</span><span class="line">except Exception:
</span><span class="line">    return jsonify(ERR_SESS_TIMEOUT)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>用途：生成一个有时间限制的签名，用于API 访问的验证码，如果过期，提醒用户重新登录</p>

<h3 id="第五节">一种较好的项目组织方式</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class=""><span class="line">▾ app/
</span><span class="line">    ▾ controlers/
</span><span class="line">        ▾ admin/                    #管理后台的蓝图控制器
</span><span class="line">            ▾ forms/                #表单限制文件
</span><span class="line">                __init__.py　　　　　
</span><span class="line">                xx.py　　　         # blueprint 文件
</span><span class="line">            __init__.py
</span><span class="line">            administrator.py
</span><span class="line">        ▾ api/                      # API 控制器
</span><span class="line">            __init__.py
</span><span class="line">        ▾ site/                     # 站点控制器
</span><span class="line">            __init__.py             # blueprint 文件
</span><span class="line">            xx.py
</span><span class="line">        __init__.py
</span><span class="line">        error.py
</span><span class="line">    ▸ models/         # SQLAlchemy 的各类模型
</span><span class="line">    ▸ static/         # 需要的静态资源，css, js, imgs
</span><span class="line">    ▾ templates/　　　# 前端页面，跟 controller 分类一一对应
</span><span class="line">        ▸ admin/
</span><span class="line">        ▸ error/
</span><span class="line">        ▸ site/
</span><span class="line">    ▸ utilities/　　　　#  功能函数
</span><span class="line">      __init__.py       #　初始化app需要的各种插件，比如 redis, db, 注册蓝图
</span><span class="line">run.py                  #　相当于 main 函数,创建 app, 执行app.run() 函数
</span><span class="line">settings.py             #　配置文件</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="第六节">BluePrint 的好 </h3>

<p>每个 Blueprint 就像独立的 Application, 可以管理自己的模板, 路由, 反向路由url_for, 甚至是静态文件，最后统一挂载到 Application 下。从头到尾都是 RestFul。</p>

<p>在创建 app (app/<strong>init</strong>.py) 的时候调用如下:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">from app.controllers.site.console import console 
</span><span class="line">app.register_blueprint(console, url_prefix='/console')</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>视图文件 (app/controllers/site/console.py):</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">console = BLueprint('console', __name__)</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="第七节">Json 返回</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">from flask import jsonify
</span><span class="line">return jsonify({'code': 0})</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="第八节">自定义出错页面</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">@app.errorhandler(404)
</span><span class="line">def not_found(error):
</span><span class="line">    return render_template('404.html'), 404
</span><span class="line">
</span><span class="line">@app.errorhandler(500)
</span><span class="line">def crash(error):
</span><span class="line">    return render_template('5xx.html'), 500</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="第九节">WTF 跨站脚本防御</h3>

<p>Flask-WTF 能保护表单免受跨站请求伪造的攻击,恶意网站把请求发送到被攻击者已经登录的其他玩战会引发 CSRF 攻击</p>

<ul>
  <li>app config 文件中，开启 CSRF 开关并配置密钥</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">CSRF_ENABLED = True
</span><span class="line">SECRET_KEY = 'you-will-never-guess'</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>表单的定义</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">from flask.ext.wtf import Form, TextField, BooleanField
</span><span class="line">from flask.ext.wtf import Required
</span><span class="line">class LoginForm(Form):
</span><span class="line">    openid = TextField('openid', validators = [Required()])
</span><span class="line">    remember_me = BooleanField('remember_me', default = False)</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>页面渲染</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">&lt;form action="" method="post" name="login"&gt;
</span><span class="line">    form.hidden_tag()
</span><span class="line">    &lt;p&gt; Please enter your OpenID:form.openid(size=80)&lt;br&gt;&lt;/p&gt;
</span><span class="line">    &lt;p&gt;form.remember_me &lt;/p&gt;
</span><span class="line">    &lt;p&gt;&lt;input type="submit" value="Sign In"&gt;&lt;/p&gt;
</span><span class="line">&lt;/form&gt;</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>控制器函数</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">@app.route('/login', methods = ['GET', 'POST'])
</span><span class="line">def login():
</span><span class="line">    form = LoginForm()
</span><span class="line">    if form.validate_on_submit():
</span><span class="line">        flash('Login requested for OpenID="' + form.openid.data))
</span><span class="line">        return redirect('/index')
</span><span class="line">    return render_template('login.html', title = 'Sign In',form = form)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们在配置中开启了CSRF(跨站伪造请求)功能，模板参数 form.hidden_tag() 会被替换成一个具有防止CSRF功能的隐藏表单字段。 在开启了CSRF功能后，所有模板的表单中都需要添加这个模板参数</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/10/01/python-shi-yong-ldap/">Python 使用 LDAP</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-01T09:49:00+08:00" pubdate data-updated="true">Oct 1<span>st</span>, 2015</time>
        
        
          | <a href="/blog/2015/10/01/python-shi-yong-ldap/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="section">写在开头</h2>

<p>过去的两个多星期，几位小伙伴同心协力完成一个自研的，类似<a href="http://pushover.net">pushover</a>的产品。感谢 Leader 的信任，让我在负责开发的同时也兼顾了一把项目经理。谢谢 IOS, Android 客户端的兄弟，设计师的支持，还有一位实习生，开心看到他的点滴成长。</p>

<p>提下背景，我们之前使用 <code>pushover</code> 来做报警推送，但是它对天朝用户不友好，Android 用户需要翻墙才能使用，有时候不稳定，体现为会收不到信息。pushove 需要付费。我们的受众不仅有程序汪，还有运营产品汪，他们需要一款更容易上手的推送软件，至少不需要番羽墙。于是自己开发一个很有必要。</p>

<p>为最大程度降低用户使用门槛，同时保证用户信息的安全，我们用了 LDAP 账户登陆，严格控制权限，以及 HTTPS 协议开发。下面提一提 LDAP 这个东西。</p>

<h2 id="ldap-">LDAP 是什么</h2>

<p><a href="https://zh.wikipedia.org/wiki/%E8%BD%BB%E5%9E%8B%E7%9B%AE%E5%BD%95%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE">LDAP维基百科</a></p>

<p>简单地讲，它是以目录树的方式存放账户信息。</p>

<p>这次项目中，我们不希望用户重新注册账户，而是采用原有的用户体系，这样对单点登录以及权限控制的好处不严而喻, LDAP 协议呼之欲出。</p>

<h2 id="virtualenv--python-ldap">virtualenv 下安装 python-ldap</h2>

<p>我们采用 Python 开发，这就需要 python-ldap 的帮助了, 记下安装笔记的好处是下次不用在此纠结太长时间。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">apt-get install libsasl2-dev python-dev libldap2-dev libssl-dev
</span><span class="line">pip install python-ldap</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-1">身份验证</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line"># LDAP 服务的域名和端口
</span><span class="line">SERVER_NAME = 'xxxx'
</span><span class="line">SERVER_PORT = xxx
</span><span class="line">try:
</span><span class="line">    conn = ldap.open(SERVER_NAME, SERVER_PORT)  
</span><span class="line">    conn.protocol_version = ldap.VERSION3 #设置ldap协议版本 
</span><span class="line">    username = "user=xxx,dc=company,dc=com" #身份信息
</span><span class="line">    password = "xxx" #访问密码
</span><span class="line">    conn.simple_bind_s(username,password) # 开始绑定，验证成功的话不会抛出异常
</span><span class="line">except ldap.LDAPError, e: #捕获出错信息
</span><span class="line">    print e</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-2">一点感悟</h2>

<p>鄙人觉得，技术领导要带领项目成长, 除了有责任把控项目风险，推进项目进度。
还必须要花很多的心血在驾驭技术上,  身先士卒去调研可行性, 以及做技术攻关，
而非命令式地分配任务，让同事干活, 只问责结果。
否则很容易导致凝聚力不足,团队技术氛围不足，这样的团队易消极，也易滋生失败的项目。
然而在天朝, 很多人存在一个潜意识:写好代码是为了以后不写代码，这种阶级思想让我反感。</p>

<p>以前看过一个新闻, 硅谷在面试技术 VP ，仍然要求其在各位工程师面前手写代码，以此作为面试的重要环节, 不得不点赞。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/10/sysdig-zhi-de-yong-you/">Sysdig 值得拥有</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-09-10T23:10:00+08:00" pubdate data-updated="true">Sep 10<span>th</span>, 2015</time>
        
        
          | <a href="/blog/2015/09/10/sysdig-zhi-de-yong-you/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>定位服务器问题时,  我们需要各式各样的武器, 诸如 iftop, ifstat, netstat, tcpdump, iostat。dstat 等, 因此工具箱需要装满很多工具, 在面对问题的时候才能显得不费吹灰之力, 迅速定位问题并解决, 保障服务稳定运行。Sysdig 的横空出世, 对我们而言, 就是一把瑞士军刀, 灵活小巧, 武艺多端.</p>

<ul>
  <li><a href="#第一节">安装</a></li>
  <li><a href="#第二节">常用操作</a></li>
  <li><a href="#第三节">高效的实战</a></li>
</ul>

<h3 id="第一节">安装</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">curl -s https://s3.amazonaws.com/download.draios.com/DRAIOS-GPG-KEY.public | apt-key add -
</span><span class="line">curl -s -o /etc/apt/sources.list.d/draios.list http://download.draios.com/stable/deb/draios.list
</span><span class="line">apt-get update
</span><span class="line">apt-get -y install sysdig</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="第二节">常用操作</h3>

<p>sysdig 有很多 chisel, chisel 意为 铲子, 可以理解为定位某类问题的工具, sysdig 采用 Lua 编写的。</p>

<ul>
  <li>查看 chisel 列表</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sysdig -cl  </span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>查看具体某个 chisel 的提示</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sysdig -i spy_logs</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>使用某个 chisel</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sysdig -c spy_logs</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>过滤器可以帮助我们从各种输出信息中, 筛选出我们需要的, 比如 
<code>proc.name=foo</code> , 
如果你记住不了太多过滤器也无妨,  我们可以借助如下命令查看过滤器</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sysdig -l</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>记录定位信息到文本, 以及从文本读取信息</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sysdig -w tracefile.cap
</span><span class="line">sysdig -r tracefile.dump proc.name=sshd</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="第三节">高效的实战</h3>

<ul>
  <li>服务器上经常需要查看哪个服务带宽占用使用较高, 特别是被 DDOS 的时候。</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo sysdig -c topprocs_net</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>查看某个IP的通讯数据,并以ASCII 码输出</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo sysdig -s2000 -A -c echo_fds fd.cip=127.0.0.1</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>查看非请求 redis-server 的其他请求进程和句柄</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo sysdig -p"%proc.name %fd.name" "evt.type=accept and proc.name!=redis-server"</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>查看访问该服务器的所有 GET 请求数据</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo sysdig -s 2000 -A -c echo_fds fd.port=80 and evt.buffer contains GET</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>查看访问该服务器的 SQL 语句</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo sysdig -s 2000 -A -c echo_fds evt.buffer contains SELECT</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>查看磁盘读写最高的进程</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sysdig -c topprocs_file</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>查看延迟最大的系统调用</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sysdig -c topscalls_time</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>查看具体文件的操作细节</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sysdig -A -c echo_fds "fd.filename=syslog"</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>查看 IO 延迟大于 1ms 的文件</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo sysdig -c fileslower 1</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>监视某个文件是否被操作, 从安全出发想象空间很大哦</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo sysdig evt.type=open and fd.name contains /etc</span></code></pre></td></tr></table></div></figure></notextile></div>

<hr />

<p><a href="http://www.sysdig.org/wiki/">Sysdig 官网</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/05/ansiblede-shi-yong-jing-yan/">Ansible 使用经验</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-09-05T18:09:00+08:00" pubdate data-updated="true">Sep 5<span>th</span>, 2015</time>
        
        
          | <a href="/blog/2015/09/05/ansiblede-shi-yong-jing-yan/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>当你只有一两台服务器的情况下，可以直接登上服务器，手敲命令完成软件部署，代码发布等工作。但假如你有10台，100台的时候，这种方式不仅浪费大量时间，而且给人为犯错带来了可能。于是我们选择 Ansible 来做自动化批量操作。</p>

<p>之前有记录一些 Ansible 入门的使用,请看<a href="http://wiki.zheng-ji.info/Sys/ansible.html">这里</a>, 这半年的积累, 总结一些实用的经验, 记录了一把。</p>

<ul>
  <li><a href="#第一节">配置 ansible.cfg 文件</a></li>
  <li><a href="#第二节">使用 ansible role 来区分业务</a></li>
  <li><a href="#第三节">files 目录的路径定位</a></li>
  <li><a href="#第四节">使用 tags 区分不同操作</a></li>
  <li><a href="#第五节">规划 ansible roles 的 tasks 文件</a></li>
  <li><a href="#第六节">ansible-play-book 一些常用的选项</a></li>
</ul>

<h3 id="第一节">更好地配置文件</h3>

<p>我们会如下配置 /etc/ansible/host, 特意指明用户与 端口</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">[web-cluster]
</span><span class="line">&lt;node-1-IP&gt; ansible_ssh_port=&lt;Your Port&gt; ansible_ssh_user=zj
</span><span class="line">&lt;node-2-IP&gt; ansible_ssh_port=&lt;Your Port&gt; ansible_ssh_user=zj</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在 /etc/ansible/ansible.cfg 文件里
我们特意提及了 ansible-role 的配置，未来我们会使用这个东西</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">roles_path    = /home/zj/my-ansible/roles</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="第二节">使用 ansible role 来区分业务</h3>

<p>打开 ansible 部署脚本的文件夹, 目录树如下</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">cd /home/zj/my-ansible/
</span><span class="line">haproxy
</span><span class="line">     - entry.yaml
</span><span class="line">roles
</span><span class="line">     - haproxy
</span><span class="line">        - files
</span><span class="line">        - handlers
</span><span class="line">        - vars
</span><span class="line">        - tasks</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我用一个管理 haproxy 的例子来讲解这种方式。
在 roles 目录下创建 haproxy, 如上所示，需要有四个目录;</p>

<ul>
  <li>files 目录下放置需要被传输到远端的文件;</li>
  <li>vars  目录下有一个 main.yml 文件,可以定义一些通用的配置变量，可以在 ansbile 脚本中使用;</li>
  <li>handlers 目录下有一个 main.yml, 可以定义一些通用的操作，比如重启服务等;</li>
  <li>tasks 目录下是我们编写 main.yml 脚本，执行业务逻辑的地方;</li>
</ul>

<blockquote>
  <p>那么 ansible role 的入口在哪呢？</p>
</blockquote>

<p>在 ~/my-ansible/haproxy/entry.yml 中，指定了roles的角色，如此一来， 
ansible-playbook 就会去 /home/zj/my-ansible/roles/haproxy 准备执行 tasks/main.yml </p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">- hosts: web-cluster
</span><span class="line">  roles:
</span><span class="line">    - haproxy</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="第三节">files 目录的路径定位</h3>

<p>摘取 ~/my-ansible/roles/haproxy/tasks/main.yml</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">- name: copy haproxy conf
</span><span class="line">  copy: src=haproxy.cfg dest=/etc/haproxy/haproxy.cfg owner=root group=root
</span><span class="line">  sudo: yes</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这里的 src=haproxy.cfg 意味着 ~/my-ansible/roles/haproxy/files/haproxy.cfg</p>

<h3 id="第四节">使用 tags 区分不同操作</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">- name: install ppa
</span><span class="line">  shell: add-apt-repository -y ppa:vbernat/haproxy-1.5
</span><span class="line">  sudo: yes
</span><span class="line">  tags:
</span><span class="line">    - install-haproxy</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>以下命令，是使用 tags 参数区分操作的例子</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">cd ~/my-ansible/haproxy
</span><span class="line">ansible-playbook entry.yml -v -K --tags "install-haproxy"</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="第五节">规划 ansible roles 的 tasks 目录</h3>

<p>tasks 目录有一个主执行文件 main.yml, 因为业务操作步骤太多，导致 main.yml 文件很长，那么可读性就下降了。为此，我们使用了 include 语法。</p>

<p>cat ~/my-ansible/roles/haproxy/tasks/main.yml</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">- include: 'install-haproxy.yml'</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>include 上述文件，这样 main.yml 就显得简洁，我们可以将相关的操作写在对应的 yml 文件里</p>

<p>cat ~/my-ansible/roles/haproxy/tasks/install-haproxy.yml</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">- name: copy haproxy conf
</span><span class="line">  copy: src=haproxy.cfg dest=/etc/haproxy/haproxy.cfg owner=root group=root
</span><span class="line">  sudo: yes
</span><span class="line">  tags:
</span><span class="line">     - install-haproxy</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>tags 最好也与该 yml 文件名一致，清晰分明</p>

<h3 id="第六节">ansible-play-book 一些常用的选项</h3>

<ul>
  <li>-K 需要 sudo 权限去客户机执行命令，会提示你输入密码</li>
  <li>-v 可以输出冗余的执行过程</li>
  <li>–check 可以测试脚本执行情况，但实际并未在远程机器执行</li>
  <li>–tags 提示 ansible-play-book 调用哪些 tags 命令</li>
</ul>

<p>使用过ansible roles 之后，最大的体会是操作调理化，甚至编程化，合理的利用 handler, vars, 能更加优雅抽象。</p>

<hr />

<p>上述的例子在 Github 有代码, 结合本文阅读可能更容易上手
<a href="https://github.com/zheng-ji/ToyCollection/tree/master/my-ansible">Link</a> </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/21/supervisorjian-ting-qi/">Supervisor 监听器</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-08-21T16:36:00+08:00" pubdate data-updated="true">Aug 21<span>st</span>, 2015</time>
        
        
          | <a href="/blog/2015/08/21/supervisorjian-ting-qi/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>我们服务多是用 supervisor 启动的， 但监控多数是用 <code>monit</code>, 如果我们能通过监测 supervisor 事件变化来做监控，就可以写一套通用的监控程序。</p>

<p>庆幸的是，supervisor 的 <code>eventListener</code> 支持我的设想。</p>

<p>这个监控程序需要用 supervisor 启动，类型不再是<code>program</code>, 而是<code>eventlistener</code>，这里有几个比较耗时的地方需要记录下。</p>

<ul>
  <li>supervisor 有独特的通信协议,需要遵循，否则通讯不会被触发</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">def write_stdout(self, s):
</span><span class="line">    sys.stdout.write(s)
</span><span class="line">    sys.stdout.flush()
</span><span class="line">
</span><span class="line">write_stdout('READY\n') //类似开始握手
</span><span class="line">write_stdout('RESULT 2\nOK') //结束通讯</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>需要从标准输入端读取事件,而且他是个阻塞的事件模型</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">while 1:
</span><span class="line">    self.write_stdout('READY\n')
</span><span class="line">    line = sys.stdin.readline()
</span><span class="line">    do_some_thing()
</span><span class="line">    self.write_stdout('RESULT 2\nOK')</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>supervisor 配置文件需要订阅事件</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">[eventlistener:alarm]
</span><span class="line">user=zj
</span><span class="line">command=/usr/bin/python /home/ymserver/bin/alarm/main.py
</span><span class="line">events=PROCESS_STATE_EXITED,PROCESS_STATE_STOPPED,PROCESS_STATE_FATAL
</span><span class="line">
</span><span class="line"># 记录控制台输出的日志位置
</span><span class="line">stderr_logfile=/home/zj/log/supervisor/alarm.err.log
</span><span class="line">stdout_logfile=/home/zj/log/supervisor/alarm.output.log</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>弄好 supervisor 配置，以及部署好代码之后，需要重启 supervisor 才会真正的订阅事件。
从此 supervisor 管理的程序一旦有 <code>FATAL</code>,<code>EXIT</code> 等状态就会触发程序，程序中就会触发自定义的报警。</p>

<hr />

<p><a href="https://github.com/zheng-ji/ToyCollection/tree/master/supervisor-listener">代码</a></p>

<p>Happy Hack!</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/16/twemproxy/">Twemproxy 一个 Redis 代理</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-08-16T12:11:00+08:00" pubdate data-updated="true">Aug 16<span>th</span>, 2015</time>
        
        
          | <a href="/blog/2015/08/16/twemproxy/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><dl>
  <dt>为解决线上 Redis 服务直连出现链接数爆棚而做的调研， 对 Twitter 开源的 twemproxy 做一些记录。 我们之所以放弃官方的 RedisCLuster 是因为不太满意其性能</dt>
  <dd>
    <p><a href="#第一节">初窥原理</a>
* <a href="#第二节">安装与配置</a>
* <a href="#第三节">不支持的操作</a>
* <a href="#第四节">压力测试</a>
* <a href="#第五节">摘自极光博客的评论</a></p>
  </dd>
</dl>

<h3 id="第一节">初窥原理</h3>

<ul>
  <li>Twitter 出品的轻量级 Redis，memcached 代理，使用它可以减少缓存服务器的连接数，并且利用它来作分片。</li>
  <li>作是说最差情况下，性能损耗不会多于20%。背后是用了pipeline，redis是支持使用pipeline批处理的。</li>
  <li>twemproxy 与每个 redis 服务器都会建立一个连接，每个连接实现了两个 FIFO 的队列， 通过这两个队列实现对 redis 的 pipeline 访问，将多个客户端的访问合并到一个连接，这样既减少了redis服务器的连接数，又提高了访问性能。</li>
</ul>

<h3 id="第二节">安装与配置</h3>

<ul>
  <li>安装</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">apt-get install automake
</span><span class="line">apt-get install libtool
</span><span class="line">git clone git://github.com/twitter/twemproxy.git
</span><span class="line">cd twemproxy
</span><span class="line">autoreconf -fvi
</span><span class="line">./configure
</span><span class="line">make
</span><span class="line">sudo make install</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>默认的可执行文件在 /usr/local/sbin/nutcracker</p>

<ul>
  <li>配置文件 /etc/nutcracker/nutcracker.yml</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">alpha:
</span><span class="line">    listen: 127.0.0.1:8877
</span><span class="line">    hash: fnv1a_64
</span><span class="line">    distribution: ketama
</span><span class="line">    auto_eject_hosts: true
</span><span class="line">    redis: true
</span><span class="line">    server_retry_timeout: 30000
</span><span class="line">    server_failure_limit: 3
</span><span class="line">    servers:
</span><span class="line">        - 127.0.0.1:6379:1 master0  #后端的redis-server
</span><span class="line">        - 127.0.0.1:6380:1 master1</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>当 redis 做缓存的使用的时候应该启用 auto_eject_hosts， 如果某个节点失败的时候将该节点删除，虽然丧失了数据的一致性，但作为缓存使用，保证了这个集群的高可用性。当redis做存储的使用时为了保持数据的一致性，应该禁用 auto_eject_hosts,也就是当某个节点失败之后并不删除该节点。</p>

<h3 id="第三节">不支持的操作</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">keys command: keys,migrate,move object,randomkey,rename,renamenx,
</span><span class="line">sort strings command: bitop,mset,msetnx
</span><span class="line">list command: blpop,brpop,brpoplpush
</span><span class="line">scripting command: script exists,script flush,script kill,script load
</span><span class="line">pub/sub command:(全部不支持)psubscribe,publish,punsubscribe,subscribe,unsubscribe</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="第四节">压测</h3>

<p>感谢 redis 提供的 redis-benchmark 工具，用它来做压测挺好的。</p>

<ul>
  <li>n 表示多少个连接</li>
  <li>r 表示多少个 key,</li>
  <li>t 代表命令</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class=""><span class="line">zj@zheng-ji.info:~$ redis-benchmark -p 6700 -t smembers,hexists,get,hget,lrange,ltrim,zcard,setex,sadd -n 1000000 -r 100000000
</span><span class="line">
</span><span class="line">====== GET ======
</span><span class="line">1000000 requests completed in 12.95 seconds
</span><span class="line">50 parallel clients
</span><span class="line">3 bytes payload
</span><span class="line">keep alive: 1
</span><span class="line">
</span><span class="line">99.19% &lt;= 1 milliseconds
</span><span class="line">99.93% &lt;= 2 milliseconds
</span><span class="line">100.00% &lt;= 2 milliseconds
</span><span class="line">77220.08 requests per second
</span><span class="line">
</span><span class="line">====== SADD ======
</span><span class="line">1000000 requests completed in 10.74 seconds
</span><span class="line">50 parallel clients
</span><span class="line">3 bytes payload
</span><span class="line">keep alive: 1
</span><span class="line">
</span><span class="line">99.88% &lt;= 1 milliseconds
</span><span class="line">99.95% &lt;= 2 milliseconds
</span><span class="line">99.97% &lt;= 3 milliseconds
</span><span class="line">99.99% &lt;= 4 milliseconds
</span><span class="line">100.00% &lt;= 4 milliseconds
</span><span class="line">93144.56 requests per second</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如作者所言, 性能几乎可以跟直连redis比拟，背后的数据也很均匀,使用twemproxy 观察连接数, 一直都保持在个位数左右。</p>

<h3 id="第五节">摘自极光博客的评论</h3>

<ul>
  <li>前端使用 Twemproxy 做代理，后端的 Redis 数据能基本上根据 key 来进行比较均衡的分布。</li>
  <li>后端一台 Redis 挂掉后，Twemproxy 能够自动摘除。恢复后，Twemproxy 能够自动识别、恢复并重新加入到 Redis 组中重新使用。</li>
  <li>Redis 挂掉后，后端数据是否丢失依据 Redis 本身的策略配置，与 Twemproxy 基本无关。</li>
  <li>如果要新增加一台 Redis，Twemproxy 需要重启才能生效；并且数据不会自动重新 Reblance，需要人工单独写脚本来实现。</li>
  <li>如同时部署多个 Twemproxy，配置文件一致（测试配置为distribution：ketama,modula），则可以从任意一个读取，都可以正确读取 key对应的值。</li>
  <li>多台 Twemproxy 配置一样，客户端分别连接多台 Twemproxy可以在一定条件下提高性能。根据 Server 数量，提高比例在 110-150%之间。</li>
  <li>如原来已经有 2 个节点 Redis，后续有增加 2 个 Redis，则数据分布计算与原来的 Redis 分布无关，现有数据如果需要分布均匀的话，需要人工单独处理。</li>
  <li>如果 Twemproxy 的后端节点数量发生变化，Twemproxy 相同算法的前提下，原来的数据必须重新处理分布，否则会存在找不到key值的情况。</li>
</ul>

<hr />

<p>参考链接</p>

<p><a href="http://blog.jpush.cn/redis-twemproxy-benchmark/">极光推送的博客</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/10/hackthon/">黑客马拉松</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-08-10T22:24:00+08:00" pubdate data-updated="true">Aug 10<span>th</span>, 2015</time>
        
        
          | <a href="/blog/2015/08/10/hackthon/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>周末参加了公司组织的黑客马拉松比赛, </p>

<p>通宵达旦完成了作品是个值得纪念的经历, 我们的产品叫做：<a href="http://pact.im">正义的朋友</a> </p>

<ul>
  <li>我们想要实现的功能是让人在紧急关头用最快速的方式联系到可以帮助你的人，于是我们通过锁屏应用来实现; </li>
  <li>用户在锁屏状态，画一个v手势，会把自己的地理位置发送给设置好的联系人，并持续每十秒发送一次周围的声音给联系人；</li>
  <li>用户在锁屏状态，画一个w手势，会发出专业的求救声</li>
</ul>

<p>这次比赛的感觉, 与当年<code>叫神马</code>团队的似曾相识, 队友非常给力, 大家都很拼, 我喜欢这种感觉, 事实上，在比赛之前，为了工作上的项目我已经几乎透支了, 队友也是一样。 但周六上午我们还是快速进入状态, 被逼的潜力果然不容小觑.  晒一张我们队伍合照.</p>

<p><img src="/images/2015/08/teammate.png" /></p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/24/ji-lu-cuo-wu-deng-lu-de-btmpwen-jian/">记录错误登陆的 Btmp 文件</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-07-24T23:06:00+08:00" pubdate data-updated="true">Jul 24<span>th</span>, 2015</time>
        
        
          | <a href="/blog/2015/07/24/ji-lu-cuo-wu-deng-lu-de-btmpwen-jian/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>今天查看了服务器时，发现 <code>/var/log/btmp</code> 日志文件较大。</p>

<p>此文件是记录错误登录的日志， 文件较大意味着有人使用密码字典登录ssh服务，
这个文件是需要用 <code>lastb</code> 命令才可读的。</p>

<p>查看尝试恶意登陆的前十个IP</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo lastb | awk '{ print $3}' | awk '{++S[$NF]} END {for(a in S) print a, S[a]}' | sort -rk2 |head</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果有有必要封阻IP的话，可以执行：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">iptables -A INPUT -i eth0 -s *.*.*.0/24 -j DROP</span></code></pre></td></tr></table></div></figure></notextile></div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/12/my-dot-cnfpei-zhi-yi-ju/">my.cnf 配置依据</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-07-12T08:35:00+08:00" pubdate data-updated="true">Jul 12<span>th</span>, 2015</time>
        
        
          | <a href="/blog/2015/07/12/my-dot-cnfpei-zhi-yi-ju/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>阅读完<a href="http://book.douban.com/subject/6873681/">构建高性能服务器</a> 一书，书中对 <code>MySQL</code> 配置做了讲解，我用烂笔头记录一番，明白它们这么配置的真正意义，形成系统的认知。</p>

<ul>
  <li><a href="#第一节">通用配置</a></li>
  <li><a href="#第二节">innodb_pool_buffer 合理配置</a></li>
  <li><a href="#第三节">文件打开数的合理设置</a></li>
  <li><a href="#第四节">打开表优化设置</a></li>
  <li><a href="#第五节">临时表的设置</a></li>
  <li><a href="#第六节">查看索引命中率</a></li>
</ul>

<h3 id="第一节">通用配置</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">skip-name-resolve:</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>禁止 MySQL 对外连接 DNS 解析 ,这一选项可以消除 MySQL 进行DNS解析时间，开启该选项，所有远程主机连接授权都要使用 IP。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">back_log=512</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>指出在 MySQL 暂停响应之前，有多少个请求被存在堆栈中。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">key_buffer_size</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>指定用于索引的缓冲区大小，增加它可得到更好的索引处理能力，对于内存 4G 左右，可设置为 256MB。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">max_allowed_packet=4M</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>设定在一次网络传输中的最大值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">thread_stack=256k</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>设置每个线程的堆栈大小，可满足普通操作。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">table_cache=614k</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>高速缓冲区的大小，当mysql访问一个表示，缓冲区还有空间，那么这个表就会被放入缓冲区，一般看峰值时间状态值，open_tables与open_cache，用于判断是否需要增加table_cache，如果open_Table接近table_cache就要增加了。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sort_buffer_size=6M</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>设定查询排序所用的缓冲区大小，是对每个链接而言，如果有100个连接，那么分配的总缓存是100*6=600M。
read_buffer_size,join_buffer_size 都是对单个链接而言。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">thread_cache_size=64</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>设置缓存中的链接线程的最大数量,4GB内存以上的我们会给64或者更大。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">query_cache_size=64M</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果该值比较小反而会影响效率，可以考虑不用。如果太大，缓存区中碎片会很多。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">tmp_table_size</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>设置内存临时表的最大值，如果超过改制，就会将临时表写入磁盘，范围是1kB-4GB。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">max_connection</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果超过该值，会出现<code>too many connections</code>。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">max_connect_errors</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>设置每个主机中连接请求异常中断最大次数，如果超过，MySQL禁止host连接请求，直到MySQL重启。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">wait_timeout = 120</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>一个请求的最大链接时间。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">thread_concurrency=8</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>该参数为服务器逻辑CPU * 2。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">skip-networking</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>该选项可以关闭连接方式，如果需要远程连接，不要开启。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">innodb_flush_log_at_trx_commit = 1</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>设置为0就是等到 innodb_log_buffer_size 队列满了之后再统一存储，默认是1，是最安全的设置。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">innodb_thread_concurrency = 8</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>服务器几个CPU就设置多少。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">read_rnd_buffer_Size = 16M</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>设置随机读的使用的缓冲区。</p>

<h3 id="第二节">innodb_buffer_pool 的合理设置</h3>

<p>不要武断的把innodb_buffer pool 配置为内存的50-80% 应具体而定。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">show status like 'innodb_buffer_pool_%'
</span><span class="line">
</span><span class="line">关注的有
</span><span class="line">innodb_buffer_pool_pages_data;
</span><span class="line">innodb_buffer_pool_page_total;
</span><span class="line">innodb_buffer_pool_read_request;
</span><span class="line">innodb_buffer_pool_reads;</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后看</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">读命中率 (innodb_buffer_pool_read_request - innodb_buffer_pool_reads) / innodb_buffer_pool_read_request;
</span><span class="line">写命中率 innodb_buffer_pool_pages_data /innodb_buffer_pool_page_total;</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>如果读写命中率都能在95%以上就很好了。</p>

<h3 id="第三节">文件打开数的合理设置依据</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">show global status like 'open_files'
</span><span class="line">show variables like 'open_file_limit';</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>比较合适的设置是 Open_files / open_files_limit * 100% &lt;= 75;</p>

<h3 id="第四节">打开表优化设置依据</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">show global status like 'open%tables';
</span><span class="line">show variable like 'table_cache';</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>比较合适</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">open_tables / opende_tables * 100 &gt; 85%;
</span><span class="line">open_Tables / table_Cache* 100% &lt; 95%；</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="第五节">临时表的设置依据</h3>

<p>每次执行语句，关于已经被创造了的临时表的数量，可以这么设置:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">show gloabl status like 'created_tmp5';
</span><span class="line">Created_tmp_disk_table / Created_tmp_tables * 100% &lt;= 25 %</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="第六节">查看索引命中率</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">show global status like 'key_read%';</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>key_cache_miss_rate = key_Read / key_read_request * 100% 小于 1% 是很好的，
意味着1000个请求有一个直接读硬盘。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/3/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Categories</h1>
<ul id="categories">
    <li><a href='/blog/categories/database'>DataBase</a></li><li><a href='/blog/categories/life'>Life</a></li><li><a href='/blog/categories/network'>NetWork</a></li><li><a href='/blog/categories/product'>Product</a></li><li><a href='/blog/categories/programe'>Programe</a></li><li><a href='/blog/categories/programe'>programe</a></li><li><a href='/blog/categories/server'>Server</a></li><li><a href='/blog/categories/system'>System</a></li>
</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/08/01/cuckoofilter/">CuckooFilter，BloomFilter的优化</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/07/23/celeryde-crontabshi-jian/">Celery的Crontab实践</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/07/16/bash-jia-zai-shun-xu/">环境变量的那些事</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/06/03/zhun-que-jian-ce-mysql-fu-zhi-yan-chi/">准确监控 MySQL 复制延迟</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/04/24/ansible-dynamic-inventory/">Ansible Dynamic Inventory</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/04/23/flume-shi-shi-shou-ji-nginx-ri-zhi/">Flume 实时收集 Nginx 日志</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/10/gai-xuan-ze-na-chong-redischi-jiu-hua-pei-zhi/">Redis 该选择哪种持久化配置</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/07/shi-shi-jian-kong-nginx-qps-de-tuo-zhan/"> 实时监控 nginx qps 的拓展</a>
      </li>
    
  </ul>
</section>
<section>
<h1>友情链接</h1>
<ul>
    <span>
        <a href="http://everet.org">EverET</a>
    </span>
    <span>
        <a href="http://forsigner.com">forsigner</a>
    </span>
    <span>
        <a href="http://blog.onlyice.net">Onlyice</a>
    </span>
</ul>
</section>

<section>
<h1>最近评论</h1>
<ul class="ds-recent-comments" data-num-items="10">
</ul>
<!--多说js加载开始，一个页面只需要加载一次 -->
<script type="text/javascript">
    var duoshuoQuery = {short_name:"zhengji"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';
        ds.async = true;ds.src = 'http://static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>
<!--多说js加载结束，一个页面只需要加载一次 -->
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - zheng-ji -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000421282'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/z_stat.php%3Fid%3D1000421282' type='text/javascript'%3E%3C/script%3E"));
  </script>
</p>

</footer>
  











</body>
</html>
